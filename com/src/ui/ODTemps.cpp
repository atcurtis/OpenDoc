//====START_GENERATED_PROLOG======================================
//
//
//   COMPONENT_NAME: odui
//
//   CLASSES: none
//
//   ORIGINS: 82,27
//
//
//   (C) COPYRIGHT International Business Machines Corp. 1995,1996
//   All Rights Reserved
//   Licensed Materials - Property of IBM
//   US Government Users Restricted Rights - Use, duplication or
//   disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
//   	
//   IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
//   ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
//   PURPOSE. IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR
//   CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
//   USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
//   OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
//   OR PERFORMANCE OF THIS SOFTWARE.
//
//====END_GENERATED_PROLOG========================================
//
/* @(#) 1.10 com/src/ui/ODTemps.cpp, odui, od96os2, odos29646d 10/31/96 12:45:43 [11/15/96 15:52:29] */
/*
 *  This file was generated by the SOM Compiler.
 *  Generated using:
 *     SOM incremental update: 2.41
 */


/*
 *      File:           ODTemps.cpp
 *
 *   Contains:  ODTemplates class methods
 *
 *   Written by:        Philip Estes
 *
 *   Copyright: (c) 1995 by IBM Corp., all rights reserved.
 *
 *   Change History (most recent first):
 *
 *     143887   11/28/95   jso      removed partkindname from templates
 *     143601   11/13/95   pfe      fixup template calls
 *     131016   07/25/95   jso      set preferred editor for part
 *     126652   07/20/95   pfe      fix for CreateTemplate call with bad fSU
 *     127295   06/27/95   pfe      pass in parteditor from registry and C functions
 *     125166   06/11/95   pfe      fixed PICONINFO initialization problem
 *     123478   06/03/95   pfe      parts should have own icon in template
 */

#ifndef SOM_Module_odtemps_Source
#define SOM_Module_odtemps_Source
#endif
#define ODTemplates_Class_Source


#define VARIABLE_MACROS

#define INCL_WINSTDFILE
#define INCL_DOS
#define INCL_DOSMODULEMGR
#define INCL_DOSRESOURCES
#define INCL_WINWORKPLACE
#define INCL_WINSTDDRAG
#define INCL_WINFRAMEMGR
#define INCL_WINWINDOWMGR
#define INCL_WINSYS
#define INCL_WINPOINTERS
#include <os2.h>

#include "odtemps.xih"
#include "odtemps.h" //143601 [pfe]
#include "string.h"

#ifndef SOM_ODStorageSystem_xh
#include <ODStor.xh>
#endif

#ifndef SOM_ODContainer_xh
#include <ODCtr.xh>
#endif

#ifndef SOM_ODDocument_xh
#include <Document.xh>
#endif

#ifndef SOM_CMDraft_xh
#include <CMDraft.xh>
#endif

#ifndef SOM_ODArbitrator_xh
#include <Arbitrat.xh>
#endif

#ifndef SOM_ODFrame_xh
   #include <frame.xh>
#endif

#ifndef SOM_ODWindow_xh
   #include <window.xh>
#endif

#ifndef SOM_Module_OpenDoc_Errors_defined
#include "ErrorDef.xh"
#endif

#ifndef _EXCEPT_
#include <Except.h>
#endif

#ifndef SOM_ODDispatcher_xh
#include <Disptch.xh>
#endif

#ifndef SOM_ODWindowState_xh
#include <WinStat.xh>
#endif

#ifndef SOM_ODShape_xh
#include <Shape.xh>
#endif

#ifndef SOM_CMStorageUnit_xh
#include <CMSU.xh>
#endif

#ifndef _ODPART_
#include <Part.xh>
#endif

#ifndef _ODMEMORY_
#include "ODMemory.h"
#endif

#ifndef SOM_Module_OpenDoc_StdProps_defined
#include <StdProps.xh>
#endif

#ifndef SOM_Module_OpenDoc_StdTypes_defined
#include <StdTypes.xh>
#endif

#ifndef _STORUTIL_
#include <StorUtil.h>
#endif

#ifndef _REGISTRY_
#include    <RManager.xh>
#include    <ODPrtReg.xh>
#include    <PartInfo.xh>
#endif

#ifndef _BARRAY_
#include <BArray.h>
#endif

//#ifdef ODDebug
//#ifndef __STRINGS__
//#include <Strings.h>
//#endif
//#endif

#ifndef SOM_ODSession_xh
#include <ODSessn.xh>
#endif

#include "ODtypesp.h"

//#ifdef _PLATFORM_OS2_
//#include "debug.h"
//#endif

#ifndef _ODUTILS_
#include <odutils.h>
#endif

//#ifndef _ODSMINIT_
//#include "ODSmInit.h"
//#endif

#define INCL_REXXSAA
#include <rexxsaa.h>

#include <time.h> //Rab
#include <qprintf.h>

/*------------------------------------------------------------------------*/
/* Globals                                                                */
/*------------------------------------------------------------------------*/

#define ODDLL "odstatry"

struct MemStuff {
   ODDraft *fDraft;
   ODDocument *fDocument;
   ODContainer *fContainer;
   ODHandle fContainerHandle;
   ODStorageUnit *fSU;
   };

MemStuff mymem;
string PartName = (string)SOMMalloc(200);
string fObjectID = (string)SOMMalloc(200);

ODBoolean fRexx = kODFalse;

HAB hab;
HMQ hmq;

char partkinddisplayname[200] = "\0";

const ODType   kODOpenDocPresNormal  = "OpenDoc:Presentation:Normal";

ODDispatcher *dispatcher;
Environment *environment;

/*------------------------------------------------------------------------*/
/*   Function Prototypes                                                  */
/*------------------------------------------------------------------------*/

void CreateMemStuff(Environment *ev, ODSession* session);

USHORT  SetTemplateEA(PSZ    pszFilePath,
                      PSZ    pszEAName,
                      PSZ    pszEAValue);

extern "C" {
MRESULT EXPENTRY ODShellWndProc(HWND hwnd, ULONG msg, MPARAM mp1, MPARAM mp2);
}

char * GoDoTemplates(ODSession *session,ODType partType,ODEditor partEditor);
void CleanUp(ODSession *session);

LONG APIENTRY RxODCreateTemplate (PSZ Name,LONG Argc,RXSTRING Argv[],PSZ Queuename,
                       PRXSTRING Retstr);

LONG APIENTRY RxODDeleteTemplate (PSZ Name,LONG Argc,RXSTRING Argv[],PSZ Queuename,
                       PRXSTRING Retstr);


/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/
/*   ODTemplates::CreateTemplate                                          */
/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/

SOM_Scope ODBoolean  SOMLINK ODTemplatesCreateTemplate(ODTemplates *somSelf,
                                                       Environment *ev,
                                                       ODPart* part,
                                                       ODSession* session,
                                                       string ObjectID,
                                                       string ObjectTitle,
                                                       ODStorageUnit* unit)

{
    ODTemplatesData *somThis = ODTemplatesGetData(somSelf);
    ODTemplatesMethodDebug("ODTemplates","ODTemplatesCreateTemplate");

    if ((!unit) || (!session) || (!part)) {
       THROW(kODErrInvalidParameter);
    } else {
       APIRET ulrc;
       char LoadError[100];
       char *parthandlername;
       HMODULE hmodDLL;
       BOOL rc;
       HOBJECT hobjrc;
       ODBoolean success = kODFalse;
       char setupString[200] = "TEMPLATE=YES;OBJECTID=";

       if (mymem.fSU == kODNULL)          //126652 [pfe]
       {                                  //a "used" storage unit cannot be passed in
         THROW(kODErrInvalidStorageUnit); //again..must throw exception.
         return kODFalse;
       }
       /* DosLoadModule on OPENDOC.DLL */

//     ulrc = DosLoadModule(LoadError,sizeof(LoadError),
//                          ODDLL,&hmodDLL);

       /* WinRegisterClass on ODstatry */

//     rc = WinRegisterObjectClass((PSZ)"ODstatry",(PSZ)ODDLL);

       /* WinCreateObject -- Templates=YES and other setup string stuff */
       if (fRexx) {
         strcat(setupString,fObjectID);
       } else {
          if (ObjectID == kODNULL) {
             string classname = part->somGetClassName();
             if (!strcmp(classname,"ODPartWrapper"))
             {
               ODPart *realPart = part->GetRealPart(ev);
               classname = realPart->somGetClassName();
               part->ReleaseRealPart(ev);
             } /* endif */
             somId classID = somIdFromString(classname);
             M_ODPart* clsPart;
             clsPart = (M_ODPart*)SOMClassMgrObject->somFindClass(classID,0,0);
             SOMFree(classID);
             parthandlername = clsPart->clsGetODPartHandlerName(ev);
             time_t creationTimeDate;
             char createString[20];
             if (unit->Exists(ev,kODPropCreateDate,kODTime_T,kODNULL))
             {
                unit->Focus(ev,kODPropCreateDate,kODPosSame,kODTime_T,0,kODPosSame);
                StorageUnitGetValue(unit, ev,sizeof(time_t),(ODValue)&creationTimeDate);
                strftime(createString, 20, "%m-%d-%y %I:%M:0p", localtime(&creationTimeDate));
             } else
             {
                time(&creationTimeDate);
                strftime(createString, 20, "%m-%d-%y %I:%M:0p", localtime(&creationTimeDate));
             } /* endif */
             ObjectID = (string)SOMMalloc(strlen(createString)+strlen(parthandlername)+7);
             strcpy(ObjectID,"<OD_");
             strcat(ObjectID,createString);
             strcat(ObjectID,parthandlername);
             strcat(ObjectID,">");
             strcat(setupString,ObjectID);
          } else {
            strcat(setupString,ObjectID);
          } /* endif */

       } /* endif */
       strcat(setupString,";");

       if (!fRexx) {
          if (ObjectTitle == kODNULL) {
            strcpy(PartName,"Part Template");  /* need work here to make unique */
                                               /* object titles for each template */
          } else {
            strcpy(PartName,ObjectTitle);
          } /* endif */
       } /* endif */

       /*
	* Try to create the Stationery at fODTempLocaton (%ODCFG%\work\statry).
	* If that fails try <OD_STATION>
	*/
       hobjrc = WinCreateObject((PSZ)"ODwps",(PSZ)PartName,
                            (PSZ)setupString,(PSZ)_fODTempLocation,
                            CO_REPLACEIFEXISTS);
       if (!hobjrc) {
	 hobjrc = WinCreateObject((PSZ)"ODwps",(PSZ)PartName,
				  (PSZ)setupString,(PSZ)"<OD_STATION>",
				  CO_REPLACEIFEXISTS);
       }

//      ulrc = DosFreeModule(hmodDLL);
       /* call WriteSUtoTemplateFile */

       if (hobjrc) {
         _fHObject = hobjrc;
         PICONINFO pIconInfo = (PICONINFO)malloc(sizeof(ICONINFO));       //125166 [pfe]

         if (mymem.fSU->Exists( ev, kODPropIconFamily, kODIconFamily, 0 ))
         {
               mymem.fSU->Focus( ev, kODPropIconFamily, kODPosUndefined, kODIconFamily,
                                   0, kODPosUndefined );

               pIconInfo->cbIconData = mymem.fSU->GetSize( ev );
               if(pIconInfo->cbIconData)
               {
                   pIconInfo->pIconData = (PVOID)new char[pIconInfo->cbIconData];
                   StorageUnitGetValue(mymem.fSU, ev, pIconInfo->cbIconData, (ODValue) pIconInfo->pIconData );
                   pIconInfo->fFormat = ICON_DATA;
                   char path[CCHMAXPATH];
                   WinQueryObjectPath(_fHObject,(PSZ)path,sizeof(path));
                   WinSetFileIcon(path,pIconInfo);
//
// This next call to WinSetObjectData really should not be 
// necessary.  For some reason, the 16x16 icon on our wps Template
// is not being updated even though we have just called 
// WinSetFileIcon.  So, to force a refresh, I call WinSetObjectData
// again to set the title.  We'll check this out on merlin to see
// if it is still a problem (RobCox, d24788)
                   BOOL mrc = 0;
                   CHAR newSetup[255];
                   strcpy(newSetup, "TITLE = ");
                   strcat(newSetup, PartName);
                   strcat(newSetup, ";");
                   mrc = WinSetObjectData(_fHObject, (PSZ)newSetup);
               }
         }
         free(pIconInfo);   //125166 [pfe]

         success = somSelf->WriteSUToTemplate(ev,session);

       } else {
          success = kODFalse;
#ifdef DEBUG
          qprintf("Could not create object..");
#endif
       } /* endif */

       if (!success) {
         hobjrc = WinQueryObject((PSZ)ObjectID);
         rc = WinDestroyObject(hobjrc);
#ifdef DEBUG
         qprintf("Could not write SU to template");
#endif
       } /* endif */

       /* return kODTrue if went ok */
       return success;

    } /* endif */
}

/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/
/*   ODTemplates::DeleteTemplate                                          */
/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/

SOM_Scope ODBoolean  SOMLINK ODTemplatesDeleteTemplate(ODTemplates *somSelf,
                                                        Environment *ev,
                                                        string ObjectID)
{
    ODTemplatesData *somThis = ODTemplatesGetData(somSelf);
    ODTemplatesMethodDebug("ODTemplates","ODTemplatesDeleteTemplate");

   HOBJECT hobj;
   ODBoolean boolrc;
   /* Query HOBJECT from Object ID */

   hobj = WinQueryObject((PSZ)ObjectID);
   boolrc = WinDestroyObject(hobj);

   return boolrc;
}
//QueryObjectID method removed. 5/11/95
/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/
/*   ODTemplates::QueryObjectID                                           */
/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/

//SOM_Scope ODUByte*  SOMLINK ODTemplatesQueryObjectID(ODTemplates *somSelf,
//                                                   Environment *ev,
//                                                  ODPart* part)
//{
//    ODTemplatesData *somThis = ODTemplatesGetData(somSelf);
//    ODTemplatesMethodDebug("ODTemplates","ODTemplatesQueryObjectID");

   /* need work on Part Registry to store ObjectIDs for each part kind */
//   return kODNULL;
//}

/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/
/*   ODTemplates::GetStorageUnit                                          */
/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/

SOM_Scope ODStorageUnit*  SOMLINK ODTemplatesGetStorageUnit(ODTemplates *somSelf,
                                                             Environment *ev,
                                                            ODSession* session)
{
    ODTemplatesData *somThis = ODTemplatesGetData(somSelf);
    ODTemplatesMethodDebug("ODTemplates","ODTemplatesGetStorageUnit");

   if (session) {
     CreateMemStuff(ev,session);
     return mymem.fSU;	
   } else {
      THROW(kODErrInvalidParameter);
   } /* endif */

}

/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/
/*   ODTemplates::WriteSUToTemplate                                       */
/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/

SOM_Scope ODBoolean  SOMLINK ODTemplatesWriteSUToTemplate(ODTemplates *somSelf,
                                                           Environment *ev,
                                                          ODSession* session)
{
    ODTemplatesData *somThis = ODTemplatesGetData(somSelf);
    ODTemplatesMethodDebug("ODTemplates","ODTemplatesWriteSUToTemplate");

   APIRET rc;
   HFILE hFile;
   ULONG ulAction, ulBytes;
   ULONG dataSize;
   BOOL rcbool;
   ODBoolean success;
   char path[CCHMAXPATH];
   PBYTE pbData;

  rcbool = WinQueryObjectPath(_fHObject,(PSZ)path,sizeof(path));

  mymem.fSU->Release(ev);
  mymem.fSU = (ODStorageUnit*) kODNULL;

  mymem.fDraft->Externalize(ev);
  mymem.fDraft->Release(ev);
  mymem.fDraft = (ODDraft*) kODNULL;

  ODFinalReleaseObject(ev,mymem.fDocument);        // [121968]
  // mymem.fDocument->Release(ev);
  mymem.fDocument = (ODDocument*) kODNULL;

  mymem.fContainer->Release(ev);
  mymem.fContainer = (ODContainer*) kODNULL;

  dataSize = ODGetHandleSize(mymem.fContainerHandle);
  ODLockHandle(mymem.fContainerHandle);
  pbData = (Ptr)*((Handle)mymem.fContainerHandle);

   rc = DosOpen( path, &hFile, &ulAction, 0, FILE_NORMAL,
                 OPEN_ACTION_CREATE_IF_NEW | OPEN_ACTION_OPEN_IF_EXISTS,
                 OPEN_SHARE_DENYNONE | OPEN_ACCESS_READWRITE, 0 );
   if ( rc )
      {
      success = kODFalse;
#ifdef DEBUG
      qprintf("Could not open template file");
#endif
      }
   else
      {
      DosWrite( hFile, (PVOID)pbData, dataSize, &ulBytes );
      DosClose( hFile );
      SetTemplateEA( path, ".TYPE", "OpenDoc Document" );
      success = kODTrue;
      }

  ODDisposeHandle(mymem.fContainerHandle);
  mymem.fContainerHandle = (ODHandle) kODNULL;

  return success;
}

/*------------------------------------------------------------------------*/
/*   ODTemplates::somInit                                                 */
/*------------------------------------------------------------------------*/
SOM_Scope void  SOMLINK ODTemplatessomInit(ODTemplates *somSelf)
{
    ODTemplatesData *somThis = ODTemplatesGetData(somSelf);
    ODTemplatesMethodDebug("ODTemplates","ODTemplatessomInit");

    ODTemplates_parent_ODObject_somInit(somSelf);

    _fODTempLocation = (string)SOMMalloc(1024);
    strcpy(_fODTempLocation, getenv("ODCFG"));
    strcat(_fODTempLocation, "\\work\\statry");

    _fHObject = kODNULL;
    _fObjID = kODNULL;
    fRexx = kODFalse;

}

/*------------------------------------------------------------------------*/
/*   ODTemplates::somUnit                                                 */
/*------------------------------------------------------------------------*/
SOM_Scope void  SOMLINK ODTemplatessomUninit(ODTemplates *somSelf)
{
    ODTemplatesData *somThis = ODTemplatesGetData(somSelf);
    ODTemplatesMethodDebug("ODTemplates","ODTemplatessomUninit");

    SOMFree(_fODTempLocation);
    ODTemplates_parent_ODObject_somUninit(somSelf);
}


/*------------------------*/
/* SetTemplateEA          */
/*------------------------*/
USHORT SetTemplateEA( PSZ pszFilePath, PSZ pszEAName, PSZ pszEAValue )
{
   USHORT       cbValue;
   USHORT       cbMem;
   USHORT       rc;
   PFEA2LIST    pfea2l;
   PSZ          ptr, ptrEnd;
   PBYTE        ptrValue, ptrCurrent;
   EAOP2        eaop;

   ptr = pszEAValue;
   cbValue = 0;
   while ( ptr && *ptr )
      {
      ptrEnd = strchr( ptr, '\n' );
      if ( !ptrEnd )
         {
         ptrEnd = &ptr[strlen(ptr)];
         }
      cbValue += ((USHORT)( ptrEnd - ptr )) + 2 * sizeof(USHORT);
      ptr = ptrEnd;
      if ( ptr && *ptr == '\n' )
         {
         ptr++;
         }
      }
   if ( cbValue )
      {
      cbValue += 3 * sizeof( USHORT );
      }
   cbMem = (USHORT)sizeof( FEA2LIST ) + strlen( pszEAName ) + (USHORT)cbValue;
   pfea2l = (PFEA2LIST) malloc( (ULONG)cbMem);
   if ( !pfea2l )
      {
      return FALSE;
      }
   memset((PCH)pfea2l,0,cbMem);
   pfea2l->cbList = cbMem;
   pfea2l->list[0].cbName = (BYTE)strlen( pszEAName );
   pfea2l->list[0].cbValue = cbValue;
   strcpy( pfea2l->list[0].szName, pszEAName );
   if ( cbValue )
      {
      ptr = pszEAValue;
      ptrValue = &pfea2l->list[0].szName[ strlen( pszEAName ) + 1 ];
      ptrCurrent = (PBYTE)(&(((PUSHORT)ptrValue)[3]));
         ((PUSHORT)ptrValue)[0] = EAT_MVMT;
      while ( ptr && *ptr )
         {
         ptrEnd = strchr( ptr, '\n' );
         if ( !ptrEnd )
            {
            ptrEnd = &ptr[strlen(ptr)];
            }
         ((PUSHORT)ptrCurrent)[0] = EAT_ASCII;
         ((PUSHORT)ptrCurrent)[1] = (USHORT)( ptrEnd - ptr );
         memcpy( &ptrCurrent[4], ptr, ((PUSHORT)ptrCurrent)[1] );
         ptrCurrent += ((PUSHORT)ptrCurrent)[1] + 4;
         ptr = ptrEnd;
         if ( ptr && *ptr == '\n' )
            {
            ptr++;
            }
         ((PUSHORT)ptrValue)[2] += 1;
         }
      }

   eaop.fpGEA2List = NULL;
   eaop.fpFEA2List = pfea2l;
   eaop.oError     = 0;

   rc = (USHORT)DosSetPathInfo( pszFilePath, 2L, &eaop, sizeof( eaop ), 0L );

   free( (CHAR *)pfea2l );

   return (USHORT)(rc);
}

/*------------------------*/
/* CreateMemStuff         */
/*------------------------*/
void CreateMemStuff(Environment *ev, ODSession *session)
{

  ODStorageUnit   *draftProperties;
  ODStorageUnitRef suRef;

  mymem.fContainerHandle = ODNewHandle(0);  // $$$ was NewHandleSys
  mymem.fContainer = CreateMemoryContainer(ev, session, mymem.fContainerHandle, kODBentoMemoryContainer);
  mymem.fDocument = mymem.fContainer->AcquireDocument(ev, kODDefaultDocument);
  mymem.fDraft = mymem.fDocument->AcquireBaseDraft(ev, kODDPExclusiveWrite);
  mymem.fSU = mymem.fDraft->CreateStorageUnit(ev);
  draftProperties = mymem.fDraft->AcquireDraftProperties(ev);
  draftProperties->AddProperty(ev, kODPropRootPartSU)->AddValue(ev, kODStrongStorageUnitRef);
  draftProperties->GetStrongStorageUnitRef(ev, mymem.fSU->GetID(ev), suRef);
  StorageUnitSetValue(draftProperties, ev, sizeof(ODStorageUnitRef), suRef);
  ODFinalReleaseObject(ev,mymem.fDocument);   // [121968]
  draftProperties->Release(ev);
}

/*----REXX-Interface-----*/
/*-----------------------*/
/* RxODDeleteTemplate    */
/*-----------------------*/
/*----REXX-Interface-----*/

LONG APIENTRY RxODDeleteTemplate (PSZ Name,LONG Argc,RXSTRING Argv[],PSZ Queuename,
                       PRXSTRING Retstr)

{
   ODTemplates *mytemp;
   mytemp = new ODTemplates;
   ODBoolean success;
   Environment *ev;
   ev = somGetGlobalEnvironment();
   char tmp[100] = "\0";

   if (Argc < 1) { return 40 ;}
   strcpy(tmp,Argv[0].strptr);
   success = mytemp->DeleteTemplate(ev,tmp);
   delete mytemp;
   Retstr->strlength = 0;
   if (success) {return 0;} else { return 1; }

}

/*----REXX-Interface-----*/
/*-----------------------*/
/* RxODCreateTemplate    */
/*-----------------------*/
/*----REXX-Interface-----*/

LONG APIENTRY RxODCreateTemplate (PSZ Name,LONG Argc,RXSTRING Argv[],PSZ Queuename,
                       PRXSTRING Retstr)
{
  ODSession *session;
  ODArbitrator *arbitrator;
  ODWindowState *windowstate;
  ODBoolean boolrc;
  ODType part;
  ODEditor editor;

  ODInitExceptions();


  session = new ODSession;
  environment = somGetGlobalEnvironment();
  session->InitSession(environment);

  dispatcher = session->GetDispatcher(environment);
  windowstate = session->GetWindowState(environment);
  arbitrator = session->GetArbitrator(environment);

  if (!dispatcher) {
#ifdef DEBUG
     qprintf("MAIN: no dispatcher");
#endif
  } /* endif */
  if (!windowstate) {
#ifdef DEBUG
     qprintf("MAIN: no window state");
#endif
  } /* endif */
  if (!arbitrator) {
#ifdef DEBUG
     qprintf("MAIN: no arbitrator");
#endif
  } /* endif */


  hab = WinInitialize(0);
  hmq = WinCreateMsgQueue(hab, 0);

  WinRegisterClass(
     hab,
     (PSZ)"OpenDocShell",
     (PFNWP)ODShellWndProc,
     CS_SIZEREDRAW,
     4);

  part = Argv[0].strptr;
  editor = Argv[1].strptr;
  char *ObjectID = GoDoTemplates(session,part,editor);
  CleanUp(session);
  Retstr->strlength = 0;
  return 0;
}

/*----C-Interface--------*/
/*-----------------------*/
/*   ODDeleteTemplate    */
/*-----------------------*/
/*----C-Interface--------*/

ODBoolean APIENTRY ODDeleteTemplate (PSZ ObjectID)

{
   ODTemplates *mytemp;
   mytemp = new ODTemplates;
   ODBoolean success;
   Environment *ev;
   ev = somGetGlobalEnvironment();
   char tmp[100] = "\0";

   strcpy(tmp,ObjectID);
   success = mytemp->DeleteTemplate(ev,tmp);
   delete mytemp;
   if (success) {return kODTrue;} else { return kODFalse; }

}

/*----C-Interface--------*/
/*-----------------------*/
/*   ODCreateTemplate    */
/*-----------------------*/
/*----C-Interface--------*/

PSZ APIENTRY ODCreateTemplate (ODType partKindName,ODEditor partEditor)

{
  ODSession *session;
  ODArbitrator *arbitrator;
  ODWindowState *windowstate;
  ODBoolean boolrc;

  ODInitExceptions();


  session = new ODSession;
  environment = somGetGlobalEnvironment();
  session->InitSession(environment);

  dispatcher = session->GetDispatcher(environment);
  windowstate = session->GetWindowState(environment);
  arbitrator = session->GetArbitrator(environment);

  if (!dispatcher) {
#ifdef DEBUG
     qprintf("MAIN: no dispatcher");
#endif
  } /* endif */
  if (!windowstate) {
#ifdef DEBUG
     qprintf("MAIN: no window state");
#endif
  } /* endif */
  if (!arbitrator) {
#ifdef DEBUG
     qprintf("MAIN: no arbitrator");
#endif
  } /* endif */


  hab = WinInitialize(0);
  hmq = WinCreateMsgQueue(hab, 0);

  WinRegisterClass(
     hab,
     (PSZ)"OpenDocShell",
     (PFNWP)ODShellWndProc,
     CS_SIZEREDRAW,
     4);

  char *ObjectID = GoDoTemplates(session,partKindName,partEditor);
  CleanUp(session);

  if (!ObjectID) {return ((char *)kODNULL);} else { return ObjectID;}
}

/*------------------------*/
/* GoDoTemplates          */
/*------------------------*/
char * GoDoTemplates(ODSession *session, ODType partType, ODEditor partEditor)
{

   ODPart *part;
   ODBoolean success = kODFalse;
   ODDraft *draft;
   ODFrame *frame;
   ODDocument *document;
   ODStorageUnit *su;
   ODStorageUnit   *draftProperties;
   ODStorageUnitRef suRef;
   ODHandle containerhandle;
   ODContainer *container;
   Environment *ev = environment;
   ODShape *shape;
   shape = new ODShape;
   shape->InitShape(ev);


   containerhandle = ODNewHandle(0);
   container = CreateMemoryContainer(ev, session, containerhandle, kODBentoMemoryContainer);
   document = container->AcquireDocument(ev, kODDefaultDocument);
   draft = document->AcquireBaseDraft(ev, kODDPExclusiveWrite);
   su = draft->CreateStorageUnit(ev);
   draftProperties = draft->AcquireDraftProperties(ev);
   draftProperties->AddProperty(ev, kODPropRootPartSU)->AddValue(ev, kODStrongStorageUnitRef);
   draftProperties->GetStrongStorageUnitRef(ev, su->GetID(ev), suRef);
   StorageUnitSetValue(draftProperties, ev, sizeof(ODStorageUnitRef), suRef);
   draftProperties->Release(ev);
   ODFinalReleaseObject(ev,document);   // [121968]

   /* create part */
   part = draft->CreatePart(ev,partType,partEditor); //127295 [pfe]
   if (!part) {
#ifdef DEBUG
      qprintf("DOTEMPS: No part!");
#endif
   } /* endif */


    /* use part registry to get info on part */

   ODPartHandlerInfo *partHandlerInfo;
   char *PartHandlerName;
   RegistryManager *registrymanager = new RegistryManager;
   ODPartHandlerRegistry *odReg = registrymanager->GetODPartHandlerRegistry(ev);

   ODPart *realPart = part->GetRealPart(ev);     //127295 [pfe]
   string classname = realPart->somGetClassName();
   somId classID = somIdFromString(classname);
   part->ReleaseRealPart(ev);
   M_ODPart* clsPart;
   clsPart = (M_ODPart*)SOMClassMgrObject->somFindClass(classID,0,0);
   PartHandlerName = clsPart->clsGetODPartHandlerName(ev);     //end 127295

   partHandlerInfo = odReg->GetPartHandlerInfo(ev,PartHandlerName);
   char *partdisplayname = partHandlerInfo->GetPartHandlerDisplayName(ev);
   strcpy(PartName,partdisplayname);

   frame = draft->CreateFrame(ev,(ODType)kODFrameObject,(ODFrame*)kODNULL,shape,
                              (ODCanvas*)kODNULL,part,(ODTypeToken)"OpenDoc:ViewAs:Frame",
                              session->Tokenize(ev,kODOpenDocPresNormal),
                              kODTrue,kODFalse);

   delete shape;

   if (!frame) {
#ifdef DEBUG
      qprintf("DOTEMPS: No frame!");
#endif
   } /* endif */

   /* clone part's storage unit */

   ODTemplates *mytemp;
   mytemp = new ODTemplates;
   ODStorageUnit *unit;
   unit = mytemp->GetStorageUnit(environment,session);

//   unit->AddProperty(ev, kODPropFrameShape);
//   frame->AcquireFrameShape(environment, kODNULL)->WriteShape(environment, unit);
   ODDraft* fromDraft = part->GetStorageUnit(environment)->GetDraft(environment);
   ODDraftKey key = fromDraft->BeginClone(ev, unit->GetDraft(ev),frame, kODCloneCut);
   part->CloneInto(ev, key, unit, frame);
   fromDraft->EndClone(ev, key);

   // Set the preferred editor in the storage unit 131016
   if (unit->Exists(ev, kODPropPreferredEditor, kODEditor, 0 ))
        unit->Focus(ev, kODPropPreferredEditor,kODPosSame,kODEditor,0,kODPosSame);
   else
   {
        unit->AddProperty(ev, kODPropPreferredEditor );
        unit->AddValue( ev, kODEditor );
   }
   StorageUnitSetValue(unit, ev, strlen(partEditor)+1,(ODValue)partEditor);

   /* call create template */
//   char ObjID[10] = "Template\0";
   strcpy(fObjectID,"<OD_");
   strcat(fObjectID,PartName);
   strcat(fObjectID,">");
   fRexx = kODTrue;
   success = mytemp->CreateTemplate(ev,part,session,fObjectID,PartName,unit);
   delete mytemp;
   if (!success) {
#ifdef DEBUG
     qprintf("Create Template didn't work!");
#endif
     return ((char *)kODNULL);
   } /* endif */
   return fObjectID;
}

/*------------------------*/
/* ODShellWndProc         */
/*------------------------*/
MRESULT EXPENTRY ODShellWndProc(HWND hwnd, ULONG msg, MPARAM mp1, MPARAM mp2)
{

   ODEventData event;
   ODBoolean handled;

   event.hwnd  = hwnd;
   event.msg   = msg;
   event.mp1   = mp1;
   event.mp2   = mp2;
   event.result = 0;


   switch (msg) {
   case WM_CREATE:
   case WM_DESTROY:
      break;
   default:
      handled = dispatcher->Dispatch(environment,&event);
      break;
   }

   if (handled)
      return event.result;
   else
      return WinDefWindowProc(hwnd, msg, mp1, mp2);

}

/*------------------------*/
/* CleanUp                */
/*------------------------*/
void CleanUp(ODSession *session)
{
   //delete session;  124619 - [pfe] 6/8/95 workaround for build
   WinDestroyMsgQueue(hmq);
   WinTerminate(hab);

}
