//====START_GENERATED_PROLOG======================================
//
//
//   COMPONENT_NAME: odui
//
//   CLASSES: none
//
//   ORIGINS: 82,27
//
//
//   (C) COPYRIGHT International Business Machines Corp. 1995,1996
//   All Rights Reserved
//   Licensed Materials - Property of IBM
//   US Government Users Restricted Rights - Use, duplication or
//   disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
//   	
//   IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
//   ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
//   PURPOSE. IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR
//   CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
//   USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
//   OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
//   OR PERFORMANCE OF THIS SOFTWARE.
//
//====END_GENERATED_PROLOG========================================
//
/* @(#) 1.3 com/src/ui/ODCnrVw.cpp, odui, od96os2, odos29646d 10/31/96 12:45:36 [11/15/96 15:52:29] */
/*
 *  This file was generated by the SOM Compiler and Emitter Framework.
 *  Generated using:
 *      SOM Emitter emitxtm: 2.41
 */
/***************************************************************************
 *   File:    odcnrvw.cpp
 *
 *   Contains:  Class definition for ODContainerView
 *
 *
 *   Copyright:  (c) 1994 by IBM Corp., all rights reserved.
 *
 *   Change History (most recent first):
 *
 *      <4>   12/06/95 BLG 145698  Open as window - check have a part to open
 *      <3>   10/24/95 BLG 141192  Add additional features to Container View
 *                                 - menu and popup menu to open a part in a window
 *                                 or request general help.
 *      <2>   09/28/95 BLG 138648  Dynamic update Container Views when their
 *                                 properties change.
 *      <1>   06/03/95 st  124328  fixes for includes/classes
 **************************************************************************/


#ifndef SOM_Module_odcnrvw_Source
#define SOM_Module_odcnrvw_Source
#endif
#define ODCnrView_Class_Source
#define VARIABLE_MACROS

#ifdef _PLATFORM_OS2_

#ifndef _ODCNRVWH_
#include <odcnrvw.h>
#endif


#ifndef _ODTYPESP_
#include <ODTypesp.h>
#endif

#endif

#ifndef SOM_ODPart_xh
#include <Part.Xh>
#endif

#ifndef SOM_ODSession_xh
#include <ODSessn.Xh>
#endif

#ifndef SOM_ODStorageUnit_xh
#include <StorageU.Xh>
#endif

#ifndef SOM_ODTypeList_xh
#include <TypeList.xh>
#endif

#ifndef SOM_ODTypeListIterator_xh
#include <TypLsItr.xh>
#endif

#ifndef SOM_ODEmbeddedFramesIterator_xh
#include <embfritr.xh>
#endif

#ifndef SOM_ODFrame_xh
#include <Frame.xh>
#endif

#ifndef _ODTYPES_
#include <ODTypes.H>
#endif

//#include <ODRes.h>

#ifndef _EXCEPT_
#include <Except.H>
#endif

#ifndef _BNDNSUTL_
#include <BndNSUtl.h>
#endif

#ifndef _STDTYPIO_
#include <StdTypIO.H>
#endif

#ifndef _STORUTIL_
#include <StorUtil.H>
#endif
// 141192
#ifndef SOM_ODWindowState_xh
#include <WinStat.xh>
#endif

#include <tempobj.h>
	
#include <malloc.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <time.h>
#include <settings.h>

#include <odviewex.xih>
#include <odcnrvw.xih>

#define CV_MAXSTRLEN 256

/***********************************************************************/
// LOCAL FUNCTIONS
/***********************************************************************/

void            ClearSourceFlags(HWND CnrWnd); // 141192
char * GetStringFromTable (ODCnrViewData *somThis,ULONG menuid);
MRESULT EXPENTRY ContainerClientProc(HWND, ULONG, MPARAM, MPARAM);
PFNWP ContainerFrameWndProc;
PFNWP ContainerSubClassProc;
MRESULT EXPENTRY ContainerSubClassFrameWndProc(HWND, ULONG, MPARAM, MPARAM);

LONG GetLenFromDataType(char *);
char *GetCategoryfromSU(Environment *ev, ODStorageUnit *su);
void CorrectXSplitBar(HWND hwnd);
void  LoadPMViewWithTree (HWND hwnd, MINIRECORDCORE *pRecordParent,
                                          PODINFO CurrentInfo, ODULong  ulViewType);
HPOINTER GetHPOINTERFromSU (Environment *ev, ODStorageUnit *su, ODPropertyName propName,
                                             ODValueType valueType);
void FreeTreeRecordContents (HWND hCnrWnd, MINIRECORDCORE *pRecord);
void ConvertViewPageDataToString(PVIEWPAGEDATA, char *,ODCnrViewData *somThis);
// start 141192  code
PODINFO2          pRecordArray[100];

//
//  Info Utility Functions (others included from bndnsutl.h)
//
ODType	ODGetKind(Environment* ev, ODPart* part)
{
	return ODGetKindFromPartSU(ev, ODGetSUFromPstObj(ev, part));
}



//-----------------------------------------------------------------
// ClearSourceFlags
//-----------------------------------------------------------------

void ClearSourceFlags(HWND CnrWnd)
{
  int i=0;
  while (pRecordArray[i] != kODNULL) {
    WinSendMsg(CnrWnd,CM_SETRECORDEMPHASIS,MPFROMP(pRecordArray[i]),
               MPFROM2SHORT(FALSE,CRA_SOURCE));
    pRecordArray[i] = kODNULL;
    i++;
  } /* endwhile */

}
// end 141192  code
/***********************************************************************/
/*  ContainerClientProc() - window procedure for the frame window.     */
/*  Called by PM whenever a message is sent to the frame.              */
/***********************************************************************/
MRESULT EXPENTRY ContainerClientProc(HWND hwnd,ULONG msg,MPARAM mp1,MPARAM mp2)
{
   Environment * ev = somGetGlobalEnvironment(); // 141192
   switch(msg)
   {
      case WM_QUIT:
      {
         break;
      }
      case WM_CLOSE:
      {
         HWND hwndParent;

         hwndParent = WinQueryWindow(hwnd,QW_PARENT);
         if (hwndParent)
            WinDestroyWindow(hwndParent);

         return (MRESULT)TRUE;
         break;
      }
      case WM_DESTROY:
      {
         ODCnrView * myCnrView = (ODCnrView *)WinQueryWindowULong(hwnd, QWL_USER);
         myCnrView->Nullhwnd(ev,hwnd);
         break;
      }

// 141192 - handle a menu selection start
      case WM_COMMAND:
      {
         ODCnrView * myCnrView = (ODCnrView *)WinQueryWindowULong(hwnd, QWL_USER);
         ODCnrViewData *somThis = ODCnrViewGetData(myCnrView);
         HWND hwndParent = WinQueryWindow(hwnd,QW_PARENT);
         ODPart * rtpart = (ODPart *)WinQueryWindowULong(hwndParent, QWL_USER);
         ODSession * fses = rtpart->GetStorageUnit(ev)->GetSession(ev);
         ODWindowState * win = fses->GetWindowState(ev);
         HWND whwnd = win->GetFrontNonFloatingPlatformWindow(ev);
         switch (SHORT1FROMMP(mp1))
         {
            case HELP_USING:
               {
               WinSendMsg(whwnd,OD_HELP,MPFROMSHORT(HLPM_MENU),MPFROM2SHORT(kODNULL,HELP_USING));
               return (MRESULT)TRUE;
               }
            case HELP_GENERAL:
               {
               WinSendMsg(whwnd,OD_HELP,MPFROMSHORT(HLPM_MENU),MPFROM2SHORT(kODNULL,HELP_GENERAL));
               return (MRESULT)TRUE;
               }
            case VIEW_OAWINDOW:
               { // send msg to container to generate a CN_ENTER message
                 WinSendMsg(hwnd,WM_CHAR,MPFROMSHORT(KC_VIRTUALKEY  ),MPFROM2SHORT(0,VK_ENTER));
                 return (MRESULT)TRUE;
               }
               break;
            default:
              return (*ContainerSubClassProc)(hwnd, msg, mp1, mp2);
         }
      }
   case WM_CONTROL:
      switch (SHORT2FROMMP(mp1)) {
      case CN_ENTER:
         {      // open part in window.
         PNOTIFYRECORDENTER  ptr2 = (PNOTIFYRECORDENTER) LONGFROMMP(mp2);
         ODINFO    * ptr3 = (ODINFO *) ptr2->pRecord;
         if (ptr3) {  // 145698
            (ptr3->part)->Open(ev,ptr3->partFrame);
         } /* endif */
         return (MRESULT)TRUE;
         }
         break;
      case CN_CONTEXTMENU:
         {
              PODINFO2 pFirstRecord = (PODINFO2) PVOIDFROMMR(WinSendMsg(hwnd,CM_QUERYRECORD,
                                                                        0,MPFROM2SHORT (CMA_FIRST,CMA_ITEMORDER)));
              ClearSourceFlags(hwnd);
              RECTL recrect;
              QUERYRECORDRECT queryrecord;
              pRecordArray[0] = (PODINFO2)PVOIDFROMMP(mp2);
              if (pRecordArray[0] != kODNULL)   //135259 if no record below mouse, no popup
              {
                PODINFO2 pTmpRecord = (PODINFO2) PVOIDFROMMR(WinSendMsg(hwnd,CM_QUERYRECORDEMPHASIS,
                                                             (PRECORDCORE)CMA_FIRST,MPFROMSHORT(CRA_SELECTED)));
                ODBoolean fSelected = kODFalse;
                int count = 0;
                while (pTmpRecord != kODNULL) {
                  if (pTmpRecord == pRecordArray[0]) {
                     fSelected = kODTrue;
                  } /* endif */
                  count ++;
                  pTmpRecord = (PODINFO2) PVOIDFROMMR(WinSendMsg(hwnd,CM_QUERYRECORDEMPHASIS,
                                                     MPFROMP(pTmpRecord),MPFROMSHORT(CRA_SELECTED)));
                } /* endwhile */
                if (fSelected && (count > 1)) {
                   //find all selected !!
                   PODINFO2 pSelRecord = (PODINFO2) PVOIDFROMMR(WinSendMsg(hwnd, CM_QUERYRECORDEMPHASIS,
                                                                (PRECORDCORE)CMA_FIRST,MPFROMSHORT(CRA_SELECTED)));
                   int i=1;
                   while (pSelRecord != kODNULL) {
                     WinSendMsg(hwnd,CM_SETRECORDEMPHASIS,MPFROMP(pSelRecord),
                                MPFROM2SHORT(TRUE,CRA_SOURCE));
                     pRecordArray[i] = pSelRecord;
                     pSelRecord = (PODINFO2) PVOIDFROMMR(WinSendMsg(hwnd, CM_QUERYRECORDEMPHASIS,
                                                        (PRECORDCORE)pRecordArray[i],MPFROMSHORT(CRA_SELECTED)));
                     i++;
                   } /* endwhile */


                } /* endif */


                queryrecord.cb = sizeof(QUERYRECORDRECT);
                queryrecord.pRecord = (PRECORDCORE)PVOIDFROMMP(mp2);
                queryrecord.fRightSplitWindow = kODTrue;
                queryrecord.fsExtent = CMA_ICON;
                WinSendMsg(hwnd,CM_QUERYRECORDRECT,
                           MPFROMP(&recrect),MPFROMP(&queryrecord));

                WinSendMsg(hwnd,CM_SETRECORDEMPHASIS,mp2,
                           MPFROM2SHORT(TRUE,CRA_SOURCE));

                POINTL pt;
                WinQueryPointerPos(HWND_DESKTOP,&pt);
                WinMapWindowPoints(HWND_DESKTOP,hwnd,&pt,1);
                pt.y = (recrect.yBottom + recrect.yTop)/2;
                WinMapWindowPoints(hwnd,HWND_DESKTOP,&pt,1);

                ODCnrView * myCnrView = (ODCnrView *)WinQueryWindowULong(hwnd, QWL_USER);
                ODCnrViewData *somThis = ODCnrViewGetData(myCnrView);
                WinPopupMenu(HWND_DESKTOP,
                             hwnd,
                             _hPopupWnd,
                             (SHORT)pt.x,
                             (SHORT)pt.y,
                             IDMS_HELP,
                             PU_SELECTITEM |
                             PU_MOUSEBUTTON1 | PU_KEYBOARD );
              } /* endif */

// 141192 - handle a menu selection end
            } return (MRESULT)FALSE;
         break;
      default:
        break;
      } /* endswitch */
   }

   /***********************************************************************/
   /*  Send the message to the usual WC_FRAME WndProc.                    */
   /***********************************************************************/
   return (MRESULT) (*ContainerSubClassProc) ( hwnd, msg, mp1, mp2 );
}

/***********************************************************************/
/*  ContainerSubClassFrameWndProc() - window procedure for the frame   */
/*  window.                                                            */
/*  Called by PM whenever a message is sent to the frame.              */
/***********************************************************************/
MRESULT EXPENTRY ContainerSubClassFrameWndProc(HWND   hwnd, ULONG msg,
                                              MPARAM mp1, MPARAM mp2)
{
   switch (msg)
   {
      /* Ram these 2 messages down the focus window's throat.  If the
       * focus window is a container, it will do something with them.
       * Otherwise we don't care.
       */
      case WM_CONTEXTMENU:
      case WM_TEXTEDIT:
         WinSendMsg(WinQueryFocus(HWND_DESKTOP),msg,mp1,mp2);
         break;
   }
   return (*ContainerFrameWndProc)(hwnd, msg, mp1, mp2);
}

LONG GetLenFromDataType(char *sType)
{
   if(!strcmp(sType, kODISOStr)) return sizeof(char *);
   if(!strcmp(sType, kODULong)) return sizeof(ODULong);
   if(!strcmp(sType, kODTime_T)) return sizeof(CTIME);
   if(!strcmp(sType, kODDate)) return sizeof(CDATE);
   if(!strcmp(sType, kODIconFamily)) return sizeof(HPOINTER);
   return 0;
}

//-----------------------------------------------------------------------------
// This routine gets the part category from the storage unit. The method used is:
// from su -> get session -> get name space manager
// from su -> get part kind types -> get first kind
// from name space mng and kind, get category list and return first category.
//-----------------------------------------------------------------------------
char *GetCategoryfromSU(Environment *ev, ODStorageUnit *su)
{
   ODNameSpaceManager* nsm = kODNULL;
   ODTypeList *kindList = kODNULL, *catList = kODNULL;
   ODTypeListIterator* kindIter = kODNULL, *catIter = kODNULL;
   ODType kind;
   char *category = kODNULL;

   nsm = su-> GetSession(ev)-> GetNameSpaceManager(ev);

   kindList = new ODTypeList;
   kindList->InitTypeList (ev, (ODTypeList *) kODNULL);
   ContentValueTypes(su, kindList);
   kindIter = kindList->CreateTypeListIterator(ev);
   if (!kindIter) return category;
   kind = kindIter->First(ev);

   catList = GetCategoriesOfKind (nsm, kind);
   if (catList) {
      catIter = catList->CreateTypeListIterator(ev);
      if (!catIter) return category;
      category = catIter->First(ev);
   }

   delete kindList;
   return category;
}

//-----------------------------------------------------------------
// CorrectXSplitBar
//-----------------------------------------------------------------

void CorrectXSplitBar(HWND hwnd)
{
  //correct the placement of the split bar after delete
  void *pRecord =  PVOIDFROMMR( WinSendMsg(hwnd,CM_QUERYRECORD,
                                             0,MPFROM2SHORT(CMA_FIRST,CMA_ITEMORDER)));

  if (pRecord != kODNULL) {
    QUERYRECORDRECT queryrecrect;
    queryrecrect.cb = sizeof(QUERYRECORDRECT);
    queryrecrect.pRecord = (PRECORDCORE)pRecord;
    queryrecrect.fRightSplitWindow = kODFalse;
    queryrecrect.fsExtent = CMA_ICON | CMA_TEXT;

    RECTL rectl;
    WinSendMsg(hwnd,CM_QUERYRECORDRECT,MPFROMP(&rectl),MPFROMP(&queryrecrect));

    CNRINFO ciInfo;
    memset(&ciInfo,0,sizeof(ciInfo));
    ciInfo.cb = sizeof(CNRINFO);
    ciInfo.xVertSplitbar = rectl.xRight ;

    WinSendMsg(hwnd,CM_SETCNRINFO, MPFROMP(&ciInfo),
               MPFROMLONG( CMA_XVERTSPLITBAR ) );
   } /* endif */
}

//---------------------------------------------------------------------------
// This method goes recursively through the ODINFO tree and builds a PM tree
// which is required for Tree view. For Details and Icon view, it does not go
// recursively.
//---------------------------------------------------------------------------
void  LoadPMViewWithTree (HWND hwnd, MINIRECORDCORE *pRecordParent,
                                          PODINFO CurrentInfo, ODULong  ulViewType)
{
   RECORDINSERT    recsIn;
   PMINIRECORDCORE     pRecordCore;
   PODINFO LeafInfo;
// LONG   AllocSize= (ulViewType==OD_DETAILSVIEW)?sizeof(ODINFO)-sizeof(MINIRECORDCORE):0;
   LONG   AllocSize= sizeof(ODINFO)-sizeof(MINIRECORDCORE); // Store all record data 141192

   pRecordCore = (PMINIRECORDCORE)WinSendMsg(hwnd, CM_ALLOCRECORD,
                         MPFROMLONG(AllocSize),MPFROMLONG( 1) );

   LeafInfo = (PODINFO) pRecordCore;  // 141192 store additional record data
   memcpy((char *) &LeafInfo->cb, (char *) &CurrentInfo->cb,
                     sizeof(ODINFO)-sizeof(MINIRECORDCORE));  // 141192
   switch(ulViewType)
   {
      case    OD_DETAILSVIEW :
      {
         LeafInfo = (PODINFO) pRecordCore;
         memcpy((char *) &LeafInfo->cb, (char *) &CurrentInfo->cb,
                     sizeof(ODINFO)-sizeof(MINIRECORDCORE));
         pRecordCore->hptrIcon = (CurrentInfo->RecordCore).hptrIcon;
         pRecordCore->pszIcon = (CurrentInfo->RecordCore).pszIcon;

         recsIn.cb = sizeof(RECORDINSERT);
         recsIn.pRecordParent = kODNULL;
         recsIn.pRecordOrder = (PRECORDCORE)CMA_END;
         recsIn.zOrder = (USHORT)CMA_TOP;
         recsIn.cRecordsInsert = (USHORT)1;
         recsIn.fInvalidateRecord = TRUE;

         WinSendMsg(hwnd,  CM_INSERTRECORD,  (PMINIRECORDCORE)LeafInfo,
                          &recsIn);

         break;
      }
      case    OD_ICONVIEW :
      {
//         pRecordCore->cb = sizeof(MINIRECORDCORE);
         pRecordCore->hptrIcon = (CurrentInfo->RecordCore).hptrIcon;
         pRecordCore->pszIcon = (CurrentInfo->RecordCore).pszIcon;

         recsIn.cb = sizeof(RECORDINSERT);
         recsIn.pRecordParent = kODNULL;
         recsIn.pRecordOrder = (PRECORDCORE)CMA_END;
         recsIn.zOrder = (USHORT)CMA_END;
         recsIn.fInvalidateRecord = TRUE;
         recsIn.cRecordsInsert = 1;
         WinSendMsg(hwnd,CM_INSERTRECORD,(PMINIRECORDCORE)pRecordCore, &recsIn);
         break;
      }
      case    OD_TREEVIEW:
      {
  //       pRecordCore->cb = sizeof(MINIRECORDCORE);
         pRecordCore->hptrIcon = (CurrentInfo->RecordCore).hptrIcon;
         pRecordCore->pszIcon = (CurrentInfo->RecordCore).pszIcon;
         if (!pRecordParent) pRecordCore->flRecordAttr = CRA_EXPANDED;

         recsIn.cb = sizeof(RECORDINSERT);
         recsIn.pRecordParent = (PRECORDCORE)pRecordParent;
         recsIn.pRecordOrder = (PRECORDCORE)CMA_END;
         recsIn.zOrder = (USHORT)CMA_END;
         recsIn.fInvalidateRecord = TRUE;
         recsIn.cRecordsInsert = 1;
         WinSendMsg(hwnd,CM_INSERTRECORD,(PMINIRECORDCORE)pRecordCore, &recsIn);
         break;
      }
   }
   if (ulViewType == OD_TREEVIEW)
      if (CurrentInfo->Leaf) LoadPMViewWithTree (hwnd,  pRecordCore,
                                 CurrentInfo->Leaf ,  ulViewType);
      if (CurrentInfo->Next) LoadPMViewWithTree (hwnd,  pRecordParent,
                                 CurrentInfo->Next ,  ulViewType);

}

//---------------------------------------------------------------------------
// This is a good routine. Do use it wherever required.
//---------------------------------------------------------------------------
HPOINTER GetHPOINTERFromSU (Environment *ev, ODStorageUnit *su,
                                        ODPropertyName propName, ODValueType valueType)
{
       HPOINTER hIcon = kODNULL;
       ODULong  len;
       PBYTE bArray;

       if (su->Exists( ev, propName, valueType, 0 ))
       {
           su->Focus( ev, propName, kODPosUndefined, valueType,
                               0, kODPosUndefined );

           len = su->GetSize( ev );
           if(len)
           {
               bArray = (PBYTE)new char[len];
               StorageUnitGetValue(su, ev, len, (ODValue) bArray);
               hIcon = WinBuildPtrHandle(bArray);
               return hIcon;
            }
       }
       return hIcon;
}

//---------------------------------------------------------------------------
// This is a recursive routine to free the icon and icon title after the Tree view
// is closed.
//---------------------------------------------------------------------------
void FreeTreeRecordContents (HWND hCnrWnd, MINIRECORDCORE *pRecord)
{
   MINIRECORDCORE *pChildRecord =  (MINIRECORDCORE *) PVOIDFROMMR(
               WinSendMsg(hCnrWnd,  CM_QUERYRECORD, MPFROMP(pRecord),
               MPFROM2SHORT(CMA_FIRSTCHILD, CMA_ITEMORDER)));

   while (pChildRecord) {

      FreeTreeRecordContents (hCnrWnd, pChildRecord);

      pChildRecord =  (MINIRECORDCORE *) PVOIDFROMMR(
                 WinSendMsg (hCnrWnd, CM_QUERYRECORD, MPFROMP(pChildRecord),
                 MPFROM2SHORT(CMA_NEXT,CMA_ITEMORDER)));
   }
   if (pRecord->pszIcon) delete[] (pRecord->pszIcon);
   if (pRecord->hptrIcon) WinDestroyPointer (pRecord->hptrIcon);
}

//---------------------------------------------------------------------------
// ConvertViewPageDataToString: Used to convert view page data into a string
// that is passed to the window in the WinSetPresParam message.
//---------------------------------------------------------------------------
void ConvertViewPageDataToString(PVIEWPAGEDATA pData, char *myStr,ODCnrViewData *somThis)
{
   sprintf(myStr, "%d.%s", FIXEDINT(pData->FontSize), pData->fattrs.szFacename);

   char str[CV_MAXSTRLEN];     // 123941
   if (pData->fattrs.fsSelection & FATTR_SEL_ITALIC) {
      WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_ITALIC, (LONG) CV_MAXSTRLEN, str);      // 123941
      strcat(myStr, str);
   //   strcat(myStr, ".Italic");
   }
   if (pData->fattrs.fsSelection & FATTR_SEL_UNDERSCORE) { // strcat(myStr, ".Underscore");
      WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_UNDERSCORE, (LONG) CV_MAXSTRLEN, str);      // 123941
      strcat(myStr, str);
   }
   if (pData->fattrs.fsSelection & FATTR_SEL_STRIKEOUT) { // strcat(myStr, ".Strikeout");
      WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_STRIKEOUT, (LONG) CV_MAXSTRLEN, str);      // 123941
      strcat(myStr, str);
   }
   if (pData->fattrs.fsSelection & FATTR_SEL_BOLD) { // strcat(myStr, ".Bold");
      WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_BOLD, (LONG) CV_MAXSTRLEN, str);      // 123941
      strcat(myStr, str);
   }
   if (pData->fattrs.fsSelection & FATTR_SEL_OUTLINE) { // strcat(myStr, ".Outline");
      WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_OUTLINE, (LONG) CV_MAXSTRLEN, str);      // 123941
      strcat(myStr, str);
   }

}

/***********************************************************************/
// SOM FUNCTIONS
/***********************************************************************/


//========================================================================
// void  ODCnrViewInitCnrView();
//------------------------------------------------------------------------
// Initializes the ODCnrView object and This will be called by the
// ODViewExtension object.
//
// Inputs
//    ViewExtobject  A reference to the ODViewExtension object.
//
//========================================================================

SOM_Scope void  SOMLINK ODCnrViewInitCnrView(   ODCnrView* somSelf,
                                                                                                                                Environment *ev,
                                                                                                                                ODViewExtension* ViewExtobject)
{
   ODCnrViewData *somThis = ODCnrViewGetData(somSelf);
   ODCnrViewMethodDebug("ODCnrView","ODCnrViewInitCnrView");

   _Parent = ViewExtobject;
   CHAR  Error[256] = "";
   DosLoadModule(Error,
                 sizeof(Error),
                 "ODRES",
                 &_hmod);
}

//===========================================================================
// void  ODCnrViewCnrDisplayView();
//---------------------------------------------------------------------------
// This method will create the PM container control window and pass the
// additional parameters to the window procedure.
//
// Inputs
//    rootpart          Part that is the root for this view
//    ulViewType        View type specified for this instance
//    ulNumberofColumns number of additional columns requested by the part
// output
//    True - worked
//    False - did not
//===========================================================================
SOM_Scope ODBoolean  SOMLINK ODCnrViewCnrDisplayView(ODCnrView *somSelf, Environment *ev,
                              ODPart* rootpart, ODULong ulViewType, ODULong ulNumberofColumns)
{
   ODCnrViewData *somThis = ODCnrViewGetData(somSelf);
   ODCnrViewMethodDebug("ODCnrView","ODCnrViewCnrDisplayView");
   ODBoolean rc = FALSE; // return a value     129740
   // If the window does not exist, then create it else resurface it.
   if (!_hCnrWnd)
   {
      FRAMECDATA      fcd;
      char FrameTitle[CV_MAXSTRLEN]; // 123941
      ULONG winID; // 138648

      /***********************************************************************/
      /* Set the attribute field to the  view, based on ulViewTypes      */
      /***********************************************************************/
      switch(ulViewType)
      {
         case OD_TREEVIEW:
             WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_TREE_VIEW, (LONG) CCHMAXPATH, FrameTitle);      // 123941
            winID = ODTREEVIEW_WINID;   // 138648
         //    strcpy(FrameTitle,"Opendoc - Tree View");
          break;

        case OD_ICONVIEW:
             WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_ICON_VIEW, (LONG) CCHMAXPATH, FrameTitle);        // 123941
//            strcpy(FrameTitle,"Opendoc - Icon View");
            winID = ODICONVIEW_WINID;           // 138648
         break;

         case OD_DETAILSVIEW:
             WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_DETAIL_VIEW, (LONG) CCHMAXPATH, FrameTitle);      // 123941
//            strcpy(FrameTitle,"Opendoc - Detail View");
            winID = ODDETAILSVIEW_WINID;        // 138648
         break;

         default:
             THROW(kODErrPMError);
      }

      /***********************************************************************/
      /*  Set up the frame control data for the frame window. Create Frame.                */
      /* Subclass frame to intercept its messages. */
      /*  Set an icon for the frame window.                                  */
      /***********************************************************************/
      fcd.cb = sizeof(FRAMECDATA);
      fcd.flCreateFlags =     FCF_TITLEBAR | FCF_SYSMENU |
                                      FCF_SIZEBORDER | FCF_SHELLPOSITION |
                                      FCF_MINMAX ;
      fcd.hmodResources = NULLHANDLE;
      fcd.idResources = 0;

      _hFrameWnd = WinCreateWindow( HWND_DESKTOP, WC_FRAME, FrameTitle,
                                0, 0, 0, 0, 0, NULLHANDLE, HWND_TOP, winID, &fcd, NULL);// 138648
      if (!_hFrameWnd) THROW(kODErrPMError);
      ContainerFrameWndProc = WinSubclassWindow(_hFrameWnd,
                                                   (PFNWP)ContainerSubClassFrameWndProc);
      WinSendMsg( _hFrameWnd, WM_SETICON, (MPARAM)WinQuerySysPointer(HWND_DESKTOP,
                        SPTR_APPICON, FALSE),NULL);
      WinSetWindowULong( _hFrameWnd, QWL_USER, (ULONG)rootpart); // 138648


      /**********************************************************************/
      /*  Create the container.                                             */
      /**********************************************************************/
      _hCnrWnd = WinCreateWindow( _hFrameWnd, WC_CONTAINER, NULL,
                         CCS_MINIICONS | CCS_MINIRECORDCORE | CCS_AUTOPOSITION | CCS_READONLY,
                         0,0,0,0, _hFrameWnd, HWND_TOP, FID_CLIENT, NULL, NULL);
      if (!_hCnrWnd) THROW(kODErrPMError);
// 141192 load the popup menu
      _hPopupWnd = WinLoadMenu( _hCnrWnd, _hmod, ID_CONTAINERVIEWPOPUP);
      HWND MenuWnd = WinLoadMenu( _hFrameWnd, _hmod, ID_CONTAINERVIEWMENUBAR);

      ContainerSubClassProc = WinSubclassWindow(_hCnrWnd,  (PFNWP)ContainerClientProc);
      WinSetWindowULong(_hCnrWnd, QWL_USER, (ULONG)somSelf);

      // if it is details view then, set other attributes

      if (ulViewType == OD_DETAILSVIEW) {

         CNRINFO         cnrInfo;
         cnrInfo.cb = sizeof(CNRINFO);

         cnrInfo.pszCnrTitle = new char  [strlen (FrameTitle)+1]; // allocate space ; // "Opendoc - Detail View"; 123941
         strcpy(cnrInfo.pszCnrTitle , FrameTitle); // "Opendoc - Detail View"; 123941
         cnrInfo.cFields = DEFAULT_NUMOFCOLS + ulNumberofColumns;
         cnrInfo.flWindowAttr =
            CV_DETAIL | CA_CONTAINERTITLE | CA_TITLESEPARATOR |  CA_DETAILSVIEWTITLES;
         WinSendMsg( _hCnrWnd,  CM_SETCNRINFO, &cnrInfo,
                     MPFROMLONG(CMA_FLWINDOWATTR | CMA_CNRTITLE));
      }

      // Get the container window attributes from the ini file
      somSelf->RestoreWindowAttributes (ev, rootpart, _hCnrWnd, ulViewType);

   } // if the window exists

   else {
      // The window is already open. So remove all the records and load them again.
      // This is done since the view may have changed now.

      USHORT flags;
      somSelf->FreeRecordContents (ev);
      flags = CMA_INVALIDATE | CMA_FREE;

      WinSendMsg (_hCnrWnd, CM_REMOVERECORD, NULL,
                                                        MPFROM2SHORT (0, flags));
      if (ulViewType == OD_DETAILSVIEW)
         WinSendMsg (_hCnrWnd, CM_REMOVEDETAILFIELDINFO, NULL,
                                                        MPFROM2SHORT (0, flags));
   }

   ODINFO   MyInfo;
   PODINFO  pMyInfo=&MyInfo;
   memset((char *)pMyInfo, 0, sizeof(ODINFO));

   // Apply the window attributes first if it is not details view.
   // For details view, we have already applied window attributes.
   // So for details view apply font, column-hiding info at the end and not here.

   if (ulViewType != OD_DETAILSVIEW)
      somSelf->ApplyWindowAttributes (ev, _ViewProps, ulViewType, FALSE);

    /**********************************************************************/
   /* Go recursively and fill pMyInfo. Then use it to fill PM Container structure. */
   /**********************************************************************/
   somSelf->IterateAndLoadInfoTree(ev, rootpart, pMyInfo);

   switch (ulViewType) {
      case OD_TREEVIEW:
         LoadPMViewWithTree (_hCnrWnd, kODNULL, pMyInfo, ulViewType);
      break;
      case OD_ICONVIEW:
         if (pMyInfo->Leaf)
            LoadPMViewWithTree (_hCnrWnd, kODNULL, pMyInfo->Leaf, ulViewType);
      break;
      case OD_DETAILSVIEW:
         if (pMyInfo->Leaf) {
            if (!ulNumberofColumns)
               LoadPMViewWithTree (_hCnrWnd, kODNULL, pMyInfo->Leaf, ulViewType);
            else
               somSelf->LoadPMViewWithAddCols (ev, rootpart, pMyInfo->Leaf,
               ulNumberofColumns, _hCnrWnd);
         }
      break;
   }

   if (ulViewType == OD_DETAILSVIEW)     {
      somSelf->InitContainerRecords(ev, _hCnrWnd, pMyInfo->Leaf,
                                DEFAULT_NUMOFCOLS + ulNumberofColumns);

      // Apply the window attributes and show the window.
      somSelf->ApplyWindowAttributes (ev, _ViewProps, ulViewType, FALSE);
   }

   rc =  WinSetWindowPos( _hFrameWnd,  HWND_TOP, 0,0,0,0,
                  SWP_ZORDER | SWP_SHOW | SWP_ACTIVATE);  //129740
   return rc; // return a value to indicate if successful   129740
}


//=============================================================================
// ODBoolean  ODCnrViewInitContainerRecords()
//-----------------------------------------------------------------------------
// InitContainerRecords will perform allocation and setup of the data shown in
// details view. It will fill in the FIELDINFO structure for each of the details
// columns, appending the part's additional columns at the end. The vertical
// splitbar will be set.
// To the left of the splitbar will be the part's icon and title.  All other
// data will appear on the right.
//=============================================================================
SOM_Scope ODBoolean  SOMLINK ODCnrViewInitContainerRecords(
                                           ODCnrView *somSelf, Environment *ev,
                                           HWND hwndCnr, PODINFO pInfoRec,
                                           ODULong ulNumberofColumns)
{
        PFIELDINFO      pStartingFieldInfo, pFieldInfo, pLeftofSB;
        FIELDINFOINSERT fieldInfoInsert;
        ODFIELDINFO Inf;
        ODULong i;
        LONG offset;
        char *sColDataType, *sPropName, *sValName;

        ODCnrViewData *somThis = ODCnrViewGetData(somSelf);
        ODCnrViewMethodDebug("ODCnrView","ODCnrViewInitContainerRecords");

        // get a structure to hold the fields
        pFieldInfo = (PFIELDINFO)WinSendMsg(hwndCnr, CM_ALLOCDETAILFIELDINFO,
                                             MPFROMLONG(ulNumberofColumns), NULL);

        // get the starting field for this link list
        pStartingFieldInfo = pFieldInfo;

        // Field #1
        pFieldInfo->cb = sizeof(FIELDINFO);
        pFieldInfo->flData =
           CFA_HORZSEPARATOR | CFA_CENTER | CFA_SEPARATOR | CFA_BITMAPORICON;
        pFieldInfo->flTitle = CFA_CENTER;
//      char stricon[CV_MAXSTRLEN];  // 123941
        pFieldInfo->pTitleData =GetStringFromTable (somThis,CV_ICON_TEXT);
//      WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
//                      CV_ICON_TEXT, (LONG) CCHMAXPATH, stricon);      // 123941
//      char * pstricon = new char[strlen (stricon )+1]; //123941
//      strcpy(pstricon ,stricon    );
//      pFieldInfo->pTitleData = pstricon;
        pFieldInfo->offStruct =  (ULONG) &(((ODINFO *)0)->RecordCore)
                                                          + (ULONG) &(((MINIRECORDCORE *)0)->hptrIcon);
        pFieldInfo = pFieldInfo->pNextFieldInfo;

        // Field #2
        pFieldInfo->cb = sizeof(FIELDINFO);
        pFieldInfo->flData = CFA_HORZSEPARATOR | CFA_LEFT |  CFA_STRING;
        pFieldInfo->flTitle = CFA_CENTER;
//      char strtitle[CV_MAXSTRLEN];  // 123941
        pFieldInfo->pTitleData =GetStringFromTable (somThis,CV_TITLE);
//      WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
//                      CV_TITLE, (LONG) CCHMAXPATH, strtitle);      // 123941
//      char * pstrtitle = new char[strlen (strtitle)+1]; //123941
//      strcpy(pstrtitle,strtitle   );
//      pFieldInfo->pTitleData =pstrtitle;
        pFieldInfo->offStruct =  (ULONG) &(((ODINFO *)0)->RecordCore)
                                                          + (ULONG) &(((MINIRECORDCORE *)0)->pszIcon);
        pLeftofSB = pFieldInfo;
        pFieldInfo = pFieldInfo->pNextFieldInfo;

        // Field #3
        pFieldInfo->cb = sizeof(FIELDINFO);
        pFieldInfo->flData = CFA_HORZSEPARATOR | CFA_LEFT | CFA_SEPARATOR | CFA_STRING;
        pFieldInfo->flTitle = CFA_CENTER;
//        char strcategory[CV_MAXSTRLEN]; // 123941
        pFieldInfo->pTitleData = GetStringFromTable (somThis,CV_CATEGORY);
//        WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
//                        CV_CATEGORY, (LONG) CCHMAXPATH, strcategory);      // 123941
//        char * pstrcategory= new char[strlen (strcategory)+1]; //123941
//        strcpy(pstrcategory,strcategory);
//        pFieldInfo->pTitleData = pstrcategory; // "Category";
        pFieldInfo->offStruct = (ULONG) &(((ODINFO *)0)->partCategory);
        pFieldInfo = pFieldInfo->pNextFieldInfo;

        // Field #4
        pFieldInfo->cb = sizeof(FIELDINFO);
        pFieldInfo->flData = CFA_HORZSEPARATOR | CFA_LEFT | CFA_SEPARATOR | CFA_STRING;
        pFieldInfo->flTitle = CFA_CENTER;
//        char strkind[CV_MAXSTRLEN];  // 123941
        pFieldInfo->pTitleData = GetStringFromTable (somThis,CV_KIND);
//        WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
//                        CV_KIND, (LONG) CCHMAXPATH, strkind);      // 123941
//        char * pstrkind= new char[strlen (strkind)+1]; //123941
//        strcpy(pstrkind,strkind);
//        pFieldInfo->pTitleData = pstrkind; // "Kind";
        pFieldInfo->offStruct = (ULONG) &(((ODINFO *)0)->partKind);
        pFieldInfo = pFieldInfo->pNextFieldInfo;

        // Field #5
        pFieldInfo->cb = sizeof(FIELDINFO);
        pFieldInfo->flData = CFA_HORZSEPARATOR | CFA_CENTER | CFA_SEPARATOR | CFA_STRING;
        pFieldInfo->flTitle = CFA_CENTER;
//        char strcdate[CV_MAXSTRLEN];  // 123941
        pFieldInfo->pTitleData = GetStringFromTable (somThis,CV_CDATE);
//        WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
//                        CV_CDATE, (LONG) CCHMAXPATH, strcdate);      // 123941
//        char * pstrcdate = new char[strlen (strcdate)+1]; //123941
//        strcpy(pstrcdate,strcdate);
//        pFieldInfo->pTitleData = pstrcdate; // "Create Date";
        pFieldInfo->offStruct = (ULONG) &(((ODINFO *)0)->partCreateDate);
        pFieldInfo = pFieldInfo->pNextFieldInfo;

        // Field #6
        pFieldInfo->cb = sizeof(FIELDINFO);
        pFieldInfo->flData = CFA_HORZSEPARATOR | CFA_CENTER | CFA_SEPARATOR | CFA_STRING;
        pFieldInfo->flTitle = CFA_CENTER;
//        char strctime[CV_MAXSTRLEN];  // 123941
        pFieldInfo->pTitleData = GetStringFromTable (somThis,CV_CTIME);
//        WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
//                        CV_CTIME, (LONG) CCHMAXPATH, strctime);      // 123941
//        char * pstrctime = new char[strlen (strctime)+1]; //123941
//        strcpy(pstrctime,strctime);
//        pFieldInfo->pTitleData = pstrctime; // "Create Time";
        pFieldInfo->offStruct = (ULONG) &(((ODINFO *)0)->partCreateTime);
        pFieldInfo = pFieldInfo->pNextFieldInfo;

        // Field #7
        pFieldInfo->cb = sizeof(FIELDINFO);
        pFieldInfo->flData = CFA_HORZSEPARATOR | CFA_CENTER | CFA_SEPARATOR | CFA_STRING;
        pFieldInfo->flTitle = CFA_CENTER;
//        char strlstmoddate[CV_MAXSTRLEN];  // 123941
        pFieldInfo->pTitleData = GetStringFromTable (somThis,CV_LST_MOD_DATE);
//        WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
//                        CV_LST_MOD_DATE, (LONG) CCHMAXPATH, strlstmoddate);      // 123941
//        char * pstrlstmoddate = new char[strlen (strlstmoddate)+1]; //123941
//        strcpy(pstrlstmoddate, strlstmoddate);
//        pFieldInfo->pTitleData = pstrlstmoddate; // "Last Modify Date";
        pFieldInfo->offStruct = (ULONG) &(((ODINFO *)0)->partLastModifyDate);
        pFieldInfo = pFieldInfo->pNextFieldInfo;

        // Field #8
        pFieldInfo->cb = sizeof(FIELDINFO);
        pFieldInfo->flData = CFA_HORZSEPARATOR | CFA_CENTER | CFA_SEPARATOR | CFA_STRING;
        pFieldInfo->flTitle = CFA_CENTER;
//        char strlstmodtime[CV_MAXSTRLEN];  // 123941
        pFieldInfo->pTitleData = GetStringFromTable (somThis,CV_LST_MOD_TIME);
//        WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
//                        CV_LST_MOD_TIME, (LONG) CCHMAXPATH, strlstmodtime);      // 123941
//        char * pstrlstmodtime = new char[strlen (strlstmodtime)+1]; //123941
//        strcpy( pstrlstmodtime, strlstmodtime);
//        pFieldInfo->pTitleData = pstrlstmodtime; // "Last Modify Time";
        pFieldInfo->offStruct = (ULONG) &(((ODINFO *)0)->partLastModifyTime);
        pFieldInfo = pFieldInfo->pNextFieldInfo;

        // Field #9
        pFieldInfo->cb = sizeof(FIELDINFO);
        pFieldInfo->flData = CFA_HORZSEPARATOR | CFA_LEFT | CFA_SEPARATOR | CFA_STRING;
        pFieldInfo->flTitle = CFA_CENTER;
//        char strlstmoduser[CV_MAXSTRLEN]; // 123941
        pFieldInfo->pTitleData = GetStringFromTable (somThis,CV_LST_MOD_USER);
//        WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
//                        CV_LST_MOD_USER, (LONG) CCHMAXPATH, strlstmoduser);      // 123941
//        char * pstrlstmoduser = new char[strlen (strlstmoduser)+1]; //123941
//        strcpy (pstrlstmoduser, strlstmoduser);
//        pFieldInfo->pTitleData = pstrlstmoduser; // "Last Modify User";
        pFieldInfo->offStruct = (ULONG) &(((ODINFO *)0)->partLastModifyUser);
        pFieldInfo = pFieldInfo->pNextFieldInfo;

        // Field #10
        pFieldInfo->cb = sizeof(FIELDINFO);
        pFieldInfo->flData = CFA_HORZSEPARATOR | CFA_CENTER | CFA_SEPARATOR | CFA_ULONG;
        pFieldInfo->flTitle = CFA_CENTER;
//        char strsize[CV_MAXSTRLEN]; // 123941
        pFieldInfo->pTitleData = GetStringFromTable (somThis,CV_SIZE);
//        WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
//                        CV_SIZE        , (LONG) CCHMAXPATH, strsize);      // 123941
//        char * pstrsize = new char[strlen (strsize)+1]; //123941
//        strcpy (pstrsize, strsize);
//        pFieldInfo->pTitleData = pstrsize; // "Size";
        pFieldInfo->offStruct = (ULONG) &(((ODINFO *)0)->partSize);
        pFieldInfo = pFieldInfo->pNextFieldInfo;

        offset = 0;
        for (i = 0; i < ulNumberofColumns - DEFAULT_NUMOFCOLS; i++) {
           _Parent->RetrieveColumnAttributes(ev, &Inf, i);
           _Parent->RetrievePartAttributes(ev, &sColDataType, &sPropName, &sValName, &i);
           pFieldInfo->cb = Inf.cb;
           pFieldInfo->flData = Inf.flDataAttrs;
           pFieldInfo->flTitle = Inf.flTitleAttrs;
           pFieldInfo->pTitleData = new char ( strlen(Inf.sTitleText)+1);
           strcpy((char *)pFieldInfo->pTitleData , Inf.sTitleText);
           pFieldInfo->offStruct = sizeof(ODINFO) + offset;
           offset += GetLenFromDataType(sColDataType);
           pFieldInfo = pFieldInfo->pNextFieldInfo;
        }

        fieldInfoInsert.cb = (ULONG)(sizeof(FIELDINFOINSERT));
        fieldInfoInsert.pFieldInfoOrder = (PFIELDINFO)CMA_FIRST;
        fieldInfoInsert.cFieldInfoInsert = (SHORT)(ulNumberofColumns);
        fieldInfoInsert.fInvalidateFieldInfo = TRUE;

        // let PM set up the fields
        WinSendMsg(hwndCnr, CM_INSERTDETAILFIELDINFO,
                       MPFROMP(pStartingFieldInfo), MPFROMP(&fieldInfoInsert));

        // Insert the split bar.
        CNRINFO ciInfo;

        memset(&ciInfo, 0, sizeof(CNRINFO));
        ciInfo.cb = sizeof(CNRINFO);
        ciInfo.pFieldInfoLast = pLeftofSB;
        ciInfo.xVertSplitbar = CX_SPLITBAR;
        WinSendMsg(hwndCnr, CM_SETCNRINFO, MPFROMP(&ciInfo),
                    MPFROMP(CMA_PFIELDINFOLAST | CMA_XVERTSPLITBAR));

        CorrectXSplitBar (hwndCnr);
//      delete pstricon; // 123941 clean up allocated memory
//      delete pstrtitle; // "
//      delete pstrcategory;
//      delete pstrkind;
//      delete pstrcdate;
//      delete pstrctime;
//      delete pstrlstmoddate;
//      delete pstrlstmodtime;
//      delete pstrlstmoduser;
//      delete pstrsize;
        return TRUE;
}


//=============================================================================
// ODBoolean ODCnrViewCnrRetrievePartAttributes()
//-----------------------------------------------------------------------------
// RetrievePartAttributes will retrieve part properties from its storage unit
// for display and insert them into an ODINFO structure and return the structure
// to the caller.
//=============================================================================
SOM_Scope ODBoolean  SOMLINK ODCnrViewCnrRetrievePartAttributes(ODCnrView *somSelf,
                                 Environment *ev, ODPart* part, PODINFO pPartInfo)
{
        ODStorageUnit   *su=kODNULL;
        ODType   kind;
        time_t  PartTimeDate;
        char PartDateString[20];
        ODULong dummy;
        ODIText *creator = kODNULL;
        char *category = kODNULL, *user = kODNULL, *title = kODNULL;
        HMODULE hMod;
        HPOINTER hIcon = kODNULL;

        ODCnrViewData *somThis = ODCnrViewGetData(somSelf);
        su = part->GetStorageUnit(ev);
        pPartInfo->part = part;

        // Field #1: Part Icon
        hIcon = GetHPOINTERFromSU (ev, su, kODPropIconFamily, kODIconFamily);
        if (hIcon) (pPartInfo->RecordCore).hptrIcon = hIcon;
        else {
           DosQueryModuleHandle(ODRES_DLL, &hMod);
           (pPartInfo->RecordCore).hptrIcon =
                                    WinLoadPointer(HWND_DESKTOP, hMod, ID_ICON);
        }

        // Field #2: Part Title
        kind = ODGetKind(ev, part);  //for DR3 port (added ev param)
        if (kind) {
           title = strrchr(kind, ':');
           if (title) title++; else title = kind;
           (pPartInfo->RecordCore).pszIcon = new char[strlen(title) + 1];
           strcpy((pPartInfo->RecordCore).pszIcon, title);
        }
        else {
//           char strUntitled[CV_MAXSTRLEN]; // 123941
//           WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
//                        CV_UNKNOWN, (LONG) CCHMAXPATH, strUntitled);      // 123941
           (pPartInfo->RecordCore).pszIcon  = GetStringFromTable (somThis,CV_UNKNOWN);
//           (pPartInfo->RecordCore).pszIcon = new char[strlen (strUntitled)+1];
//           strcpy((pPartInfo->RecordCore).pszIcon, strUntitled); // 123941 "Untitled");
        }

        // Field #3: Part Category
        category = GetCategoryfromSU(ev, su);
        if (category) {
           pPartInfo->partCategory = new char[strlen(category) + 1];
           strcpy(pPartInfo->partCategory, category);
        }
        else {
//           char strUnknown[CV_MAXSTRLEN]; // 123941
//           WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
//                        CV_UNKNOWN, (LONG) CCHMAXPATH, strUnknown);      // 123941
           pPartInfo->partCategory  = GetStringFromTable (somThis,CV_UNKNOWN);
//           pPartInfo->partCategory = new char[strlen(strUnknown)+1];
//           strcpy(pPartInfo->partCategory,strUnknown); //123941  "Unknown");
        }

        // Field #4: Part Kind
        kind = ODGetKind(ev, part); //for DR3 port (added ev param)
        pPartInfo->partKind = new char[strlen(kind)+1];
        strcpy(pPartInfo->partKind, kind);


        // Field #5, #6: Creation Date and Time
        memset(&PartTimeDate, 0, sizeof(time_t));
        su->Focus(ev,kODPropCreateDate,kODPosSame,kODTime_T,0,kODPosSame);
        StorageUnitGetValue(su,ev,sizeof(time_t),(ODValue)&PartTimeDate);
        pPartInfo->partCreateDate = new char[9];
        pPartInfo->partCreateTime = new char[11];
        strftime(PartDateString,20,"%m-%d-%y %I:%M:%S",localtime(&PartTimeDate));
        strncpy(pPartInfo->partCreateDate,PartDateString,8);
        pPartInfo->partCreateDate[8] = '\0';
        strncpy(pPartInfo->partCreateTime,PartDateString+9,10);

        // Field #7, #8: Modification Date and Time
        memset(&PartTimeDate, 0, sizeof(time_t));
        su->Focus(ev,kODPropModDate,kODPosSame,kODTime_T,0,kODPosSame);
        StorageUnitGetValue(su,ev,sizeof(time_t),(ODValue)&PartTimeDate);
        pPartInfo->partLastModifyDate = new char[9];
        pPartInfo->partLastModifyTime = new char[11];
        strftime(PartDateString,20,"%m-%d-%y %I:%M:%S",localtime(&PartTimeDate));
        strncpy(pPartInfo->partLastModifyDate,PartDateString,8);
        pPartInfo->partLastModifyDate[8] = '\0';
        strncpy(pPartInfo->partLastModifyTime,PartDateString+9,10);

        // Field #9: Last Modify User
        creator = ODGetITextProp(ev,su,kODPropModUser,kODOS2IText,kODNULL); //for DR3 port, added ev param
        if (creator)  GetITextString(creator, user);
        if (user) {
        pPartInfo->partLastModifyUser = new char[strlen(user) + 1];
        strcpy(pPartInfo->partLastModifyUser, user);
        }
        else {
//           char strUnknown[CV_MAXSTRLEN]; // 123941
//           WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
           pPartInfo->partLastModifyUser  = GetStringFromTable (somThis,CV_UNKNOWN);
//                        CV_UNKNOWN, (LONG) CCHMAXPATH, strUnknown);      // 123941
//           pPartInfo->partLastModifyUser = new char[strlen(strUnknown)+1];// 123941
//           strcpy(pPartInfo->partLastModifyUser,strUnknown ); // 123941 "Unknown");
        }

        // Field #10: Part Size
        su->Focus(ev, kODNULL, kODPosAll, kODNULL, 0, kODPosUndefined);
        pPartInfo->partSize = su->GetSize(ev);

        if (pPartInfo)
           return(TRUE);
        else
           return(FALSE);
}

//=============================================================================
// ODBoolean  ODCnrViewSaveWindowAttributes();
//-----------------------------------------------------------------------------
// SaveWindowAttributes will save the PM presentation parameters to the INI file
// for the part that is the root of the view.  The PM presentation parameters
// are:
//    -window size and position
//    -window font
//    -background container color
//    -foreground icon text color
//    The Part name property and the View type will be used  as the application
//    name and key name  for storage in the INI file.
//
// Inputs
//    rootpart    Part that will be root when view is displayed
//    hwndCnr     Handle of the  container window
//    ulViewType  Type of view that is being saved (OD_ICONVIEW,
//                                  OD_TREEVIEW, OD_DETAILSVIEW)
//
//Return
//    ODBoolean   TRUE for successful completion
//                FALSE for error
//=============================================================================
SOM_Scope ODBoolean  SOMLINK ODCnrViewSaveWindowAttributes(
                                           ODCnrView *somSelf, Environment *ev,
                                           ODPart* rootpart, HWND hwndCnr,
                                           ODULong ulViewType)
{
   //TEMPS JOHN this pm aspect should be done --- need information
   ULONG sizeinfo, positioninfo, fontinfo, bkcolorinfo, icontextcolorinfo;

   ODCnrViewData *somThis = ODCnrViewGetData(somSelf);
   ODCnrViewMethodDebug("ODCnrView","ODCnrViewSaveWindowAttributes");

   HAB  hab;
   HINI hini;

   hab = WinInitialize(0);


   char strSystem_ini[CV_MAXSTRLEN]; // 123941
   WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_SYSTEM_INI, (LONG) CV_MAXSTRLEN, strSystem_ini);      // 123941
   if ((hini = PrfOpenProfile(hab, strSystem_ini))== NULL) //"system.ini")) == NULL) // Open the INI file
      return(FALSE);                      // file was not created

   // Write the ini records for
   //    -window size and position
   char strsize[CV_MAXSTRLEN]; // 123941
   WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_SIZE      , (LONG) CV_MAXSTRLEN, strsize);      // 123941
   char strParts[CV_MAXSTRLEN]; // 123941
   WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_PARTS      , (LONG) CV_MAXSTRLEN, strParts);      // 123941
   char strPosition[CV_MAXSTRLEN]; // 123941
   WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_POSITION  , (LONG) CV_MAXSTRLEN, strPosition);      // 123941
   char strFonts[CV_MAXSTRLEN]; // 123941
   WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_FONTS   , (LONG) CV_MAXSTRLEN, strFonts);      // 123941
   char strBckClr[CV_MAXSTRLEN]; // 123941
   WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_BCK_COLOR, (LONG) CV_MAXSTRLEN, strBckClr);      // 123941
   char strIconTxtClr [CV_MAXSTRLEN]; // 123941
   WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_ICON_TXT_CLR, (LONG) CV_MAXSTRLEN, strIconTxtClr);      // 123941

   PrfWriteProfileData(hini, strParts, strsize, &sizeinfo, sizeof(sizeinfo));
   PrfWriteProfileData( hini, strParts, strPosition, &positioninfo,
                        sizeof(positioninfo));
   //    -window font
   PrfWriteProfileData(hini, strParts, strFonts, &fontinfo, sizeof(fontinfo));
   //    -background container color
   PrfWriteProfileData( hini, strParts, strBckClr, &bkcolorinfo,
                        sizeof(bkcolorinfo));
   //    -foreground icon text color
   PrfWriteProfileData( hini, strParts, strIconTxtClr, &icontextcolorinfo,
                        sizeof(icontextcolorinfo));

   return(TRUE);
}

//=============================================================================
// ODBoolean ODCnrViewRestoreWindowAttributes();
//-----------------------------------------------------------------------------
// RestoreWindowAttributes will retrieve the PM presentation parameters for the
// parts view from the INI file. This call will be made after the PM container
// control window has been created.  Default values will be used for the initial
// opening of this window as there will be no entries in the INI file to restore.
//
// Inputs
//    rootpart       Part that will be root when view is displayed
//    hwndCnr        Handle of the  container window
//    ulViewType     Type of view that is being restored (OD_ICONVIEW,
//                   OD_TREEVIEW, OD_DETAILSVIEW)
//
// Return
//    OdBoolean      TRUE for successful completion
//                   FALSE for error
//=============================================================================
SOM_Scope ODBoolean  SOMLINK ODCnrViewRestoreWindowAttributes(
                                           ODCnrView *somSelf, Environment *ev,
                                           ODPart* rootpart, HWND hwndCnr,
                                           ODULong ulViewType)
{
   ODCnrViewData *somThis = ODCnrViewGetData(somSelf);
   ODCnrViewMethodDebug("ODCnrView","ODCnrViewRestoreWindowAttributes");

   ULONG cb = 0;
   char *kind, typeName[CV_MAXSTRLEN];
   PVIEWPAGEDATA pData;
   int fs = 0;
   char str1[5], *next = NULL, sdef[FACESIZE], *next2 = NULL;

//   _ViewProps = kODNULL;   // 145698
   if (_ViewProps) {
      delete _ViewProps;
   } /* endif */
// _ViewProps = malloc (sizeof(VIEWPAGEDATA));
   _ViewProps = new VIEWPAGEDATA;

   if (! _ViewProps) return FALSE;
   memset (_ViewProps, 0, sizeof(VIEWPAGEDATA));

   kind = ODGetKind(ev, rootpart); //for DR3 port, added ev param.

   switch (ulViewType) {
      case OD_ICONVIEW:
         WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_OD_ICONVIEW, (LONG) CV_MAXSTRLEN, typeName  );      // 123941
//       strcpy (typeName, strtxt); // 123941 "OD_ICONVIEW");
      break;
      case OD_TREEVIEW:
         WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_OD_TREEVIEW, (LONG) CV_MAXSTRLEN, typeName  );      // 123941
//       strcpy (typeName,strtxt ); // 123941   "OD_TREEVIEW");
      break;
      case OD_DETAILSVIEW:
         WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_OD_DETAILVIEW, (LONG) CV_MAXSTRLEN, typeName  );      // 123941
//       strcpy (typeName, strtxt ); // 123941  "OD_DETAILSVIEW");
      break;
      default:
         return FALSE;
   } /* endswitch */

   PrfQueryProfileSize(HINI_USER, kind, typeName, &cb);

   if (cb == sizeof(VIEWPAGEDATA)) {

      PrfQueryProfileData(HINI_USER, kind, typeName, _ViewProps, &cb);
      pData = (PVIEWPAGEDATA)_ViewProps;

   } else {

      pData = (PVIEWPAGEDATA)_ViewProps;
      switch (ulViewType) {
         case OD_ICONVIEW:
            pData->ViewFlags = VIEW_ICONNONGRID | VIEW_ICONTEXTVISIBLE;
         break;
         case OD_TREEVIEW:
            pData->ViewFlags = VIEW_TREELINES | VIEW_TREETEXTVISIBLE;
         break;
         case OD_DETAILSVIEW:
            pData->ViewFlags = VIEW_CATEGORY | VIEW_KIND | VIEW_CREATEDATE
                                      | VIEW_CREATETIME | VIEW_MODIFYDATE |
                                       VIEW_MODIFYTIME | VIEW_LASTUSER | VIEW_SIZE;
         break;
      } /* endswitch */

      strcpy(sdef, ODVIEW_DEFAULTFONT);

      next = strchr (sdef, '.');
      strncpy(str1, sdef, next - sdef);
      str1[next-sdef] = 0;
      fs = atoi (str1);
      pData->FontSize = MAKEFIXED (fs, 0);

      strcpy(pData->fattrs.szFacename, ++next);
      next2 = strchr (next, '.');
      if (next2) {
         strncpy(pData->FontName, next, next2-next);
         pData->FontName[next2-next] = 0;
      } else {
         strcpy(pData->FontName, next);
      } /* endif */

      char strItalic [CV_MAXSTRLEN]; // 123941
      WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_ITALIC, (LONG) CV_MAXSTRLEN, strItalic    );      // 123941
      if (strstr(next, strItalic)) pData->fattrs.fsSelection |= FATTR_SEL_ITALIC;
      char strUnderscore [CV_MAXSTRLEN]; // 123941
      WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_UNDERSCORE, (LONG) CV_MAXSTRLEN, strUnderscore );      // 123941
      if (strstr(next,strUnderscore )) pData->fattrs.fsSelection |= FATTR_SEL_UNDERSCORE;
      char strStrikeout  [CV_MAXSTRLEN]; // 123941
      WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_STRIKEOUT , (LONG) CV_MAXSTRLEN, strStrikeout  );      // 123941
      if (strstr(next,strStrikeout )) pData->fattrs.fsSelection |= FATTR_SEL_STRIKEOUT;
      char strBold       [CV_MAXSTRLEN]; // 123941
      WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_BOLD      , (LONG) CV_MAXSTRLEN, strBold       );      // 123941
      if (strstr(next,strBold )) pData->fattrs.fsSelection |= FATTR_SEL_BOLD;
      char strOutline    [CV_MAXSTRLEN]; // 123941
      WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
                        CV_OUTLINE   , (LONG) CV_MAXSTRLEN, strOutline    );      // 123941
      if (strstr(next,strOutline)) pData->fattrs.fsSelection |= FATTR_SEL_OUTLINE;

   } /* end if */

   return(TRUE);
}

//=============================================================================
// ODBoolean ODCnrViewCnrApplyWindowAttributes()
//-----------------------------------------------------------------------------
// This method uses the VIEWPAGEDATA structure to apply window attributes to
// the container. VIEWPAGEDATA is defined in settings.h
// If bInvalidate is FALSE, then all the attributes are applied, otherwise, only those that
// are changed are applied.
//=============================================================================
SOM_Scope ODBoolean  SOMLINK ODCnrViewApplyWindowAttributes(ODCnrView *somSelf,
        Environment *ev, void *pWindowAttrs, ODULong ulViewType, ODBoolean bInvalidate)
{
   ODCnrViewData *somThis = ODCnrViewGetData(somSelf);
   ODCnrViewMethodDebug("ODCnrView","ODCnrViewApplyWindowAttributes");

   PVIEWPAGEDATA pNewData = (PVIEWPAGEDATA)pWindowAttrs;
   PVIEWPAGEDATA pOldData = (PVIEWPAGEDATA)_ViewProps;
   CNRINFO cnrInfo;

   memset(&cnrInfo, 0, sizeof(CNRINFO));
   cnrInfo.cb = sizeof(CNRINFO);

   switch (ulViewType) {

      case OD_TREEVIEW:

         if (!bInvalidate || (pOldData->ViewFlags != pNewData->ViewFlags) ) {

            cnrInfo.flWindowAttr = CV_TREE;

            if (pNewData->ViewFlags &  VIEW_TREELINES)
               cnrInfo.flWindowAttr |= CA_TREELINE;

            if (pNewData->ViewFlags &  VIEW_TREESMALLICON)
               cnrInfo.flWindowAttr |= CV_ICON | CV_MINI;
            else {
               if (pNewData->ViewFlags &  VIEW_TREEINVISIICON)
                  cnrInfo.flWindowAttr |= CV_TEXT;
               else cnrInfo.flWindowAttr |= CV_ICON;
            }

            if (!bInvalidate || ((pOldData->ViewFlags & VIEW_TREETEXTVISIBLE) !=
                     (pNewData->ViewFlags & VIEW_TREETEXTVISIBLE)))       // 138648 start
            {
               if (pNewData->ViewFlags & VIEW_TREETEXTVISIBLE)
                  WinSendMsg(_hCnrWnd, CM_SETTEXTVISIBILITY, MPFROMLONG(1), 0);
               else
                  WinSendMsg(_hCnrWnd, CM_SETTEXTVISIBILITY, 0, 0);
            }                                                            // 138648 end
            WinSendMsg( _hCnrWnd,  CM_SETCNRINFO, &cnrInfo,
                     MPFROMLONG(CMA_FLWINDOWATTR | CMA_CNRTITLE));
         }

      break;

      case OD_ICONVIEW:

         if (!bInvalidate || (pOldData->ViewFlags != pNewData->ViewFlags)){

            cnrInfo.flWindowAttr = CV_ICON;

            if (pNewData->ViewFlags &  VIEW_ICONIVISIICON) {
               if (pNewData->ViewFlags &  VIEW_ICONFLOWED)
                  cnrInfo.flWindowAttr = CV_FLOW | CV_TEXT;
               else {
                  if (pNewData->ViewFlags &  VIEW_ICONNONGRID)
                     cnrInfo.flWindowAttr = CV_ICON | CV_MINI | CA_DRAWBITMAP;
                  else
                     cnrInfo.flWindowAttr =  CV_TEXT;
               }
            } else {
               if (pNewData->ViewFlags &  VIEW_ICONSMALLICON) {
                  if (pNewData->ViewFlags &  VIEW_ICONFLOWED)
                     cnrInfo.flWindowAttr = CV_FLOW | CV_NAME | CV_MINI;
                  else {
                     if (pNewData->ViewFlags &  VIEW_ICONNONGRID)
                        cnrInfo.flWindowAttr = CV_ICON | CV_MINI;
                     else
                        cnrInfo.flWindowAttr =  CV_NAME | CV_MINI;
                  }
               } else {
                  if (pNewData->ViewFlags &  VIEW_ICONFLOWED)
                     cnrInfo.flWindowAttr = CV_FLOW | CV_NAME;
                  else {
                     if (pNewData->ViewFlags &  VIEW_ICONNONGRID)
                        cnrInfo.flWindowAttr = CV_ICON;
                     else
                        cnrInfo.flWindowAttr =  CV_NAME;
                  }
               }
            }
            if (!bInvalidate || ((pOldData->ViewFlags & VIEW_ICONTEXTVISIBLE) !=
                     (pNewData->ViewFlags & VIEW_ICONTEXTVISIBLE)))            // 138648 start
            {
               if (pNewData->ViewFlags & VIEW_ICONTEXTVISIBLE)
                  WinSendMsg(_hCnrWnd, CM_SETTEXTVISIBILITY, MPFROMLONG(1), 0);
               else
                  WinSendMsg(_hCnrWnd, CM_SETTEXTVISIBILITY, 0, 0);
            }                                                                // 138648 end

            WinSendMsg( _hCnrWnd,  CM_SETCNRINFO, &cnrInfo,
                     MPFROMLONG(CMA_FLWINDOWATTR | CMA_CNRTITLE));
         }

      break;

      case OD_DETAILSVIEW:

         // Here we get the pointer to the third column. Set the visibility of
         // columns 3 thru 10. If this does not work, we are DEAD.

         if (!bInvalidate || (pOldData->ViewFlags != pNewData->ViewFlags)) {

            PFIELDINFO pfInfo = kODNULL;

            // first col
            pfInfo = (PFIELDINFO) PVOIDFROMMR (WinSendMsg( _hCnrWnd,
                     CM_QUERYDETAILFIELDINFO, 0,  MPFROMSHORT(CMA_FIRST)));
            if (!pfInfo) break;

            // second col
            pfInfo = (PFIELDINFO) PVOIDFROMMR (WinSendMsg( _hCnrWnd,
            CM_QUERYDETAILFIELDINFO, MPFROMP(pfInfo),  MPFROMSHORT(CMA_NEXT)));
            if (!pfInfo) break;

            // Now start changing flags as you wish.
            //third col
            pfInfo = (PFIELDINFO) PVOIDFROMMR (WinSendMsg( _hCnrWnd,
            CM_QUERYDETAILFIELDINFO, MPFROMP(pfInfo),  MPFROMSHORT(CMA_NEXT)));
            if (!pfInfo) break;
            if (pNewData->ViewFlags & VIEW_CATEGORY)
               pfInfo->flData &= ~CFA_INVISIBLE;
            else
               pfInfo->flData |= CFA_INVISIBLE;

            // fourth col
            pfInfo = (PFIELDINFO) PVOIDFROMMR (WinSendMsg( _hCnrWnd,
            CM_QUERYDETAILFIELDINFO, MPFROMP(pfInfo),  MPFROMSHORT(CMA_NEXT)));
            if (pNewData->ViewFlags & VIEW_KIND)
               pfInfo->flData &= ~CFA_INVISIBLE;
            else
               pfInfo->flData |= CFA_INVISIBLE;

            // fifth col
            pfInfo = (PFIELDINFO) PVOIDFROMMR (WinSendMsg( _hCnrWnd,
            CM_QUERYDETAILFIELDINFO, MPFROMP(pfInfo),  MPFROMSHORT(CMA_NEXT)));
            if (pNewData->ViewFlags & VIEW_CREATEDATE)
               pfInfo->flData &= ~CFA_INVISIBLE;
            else
               pfInfo->flData |= CFA_INVISIBLE;

            // sixth col
            pfInfo = (PFIELDINFO) PVOIDFROMMR (WinSendMsg( _hCnrWnd,
            CM_QUERYDETAILFIELDINFO, MPFROMP(pfInfo),  MPFROMSHORT(CMA_NEXT)));
            if (pNewData->ViewFlags & VIEW_CREATETIME)
               pfInfo->flData &= ~CFA_INVISIBLE;
            else
               pfInfo->flData |= CFA_INVISIBLE;

            // seventh col
            pfInfo = (PFIELDINFO) PVOIDFROMMR (WinSendMsg( _hCnrWnd,
            CM_QUERYDETAILFIELDINFO, MPFROMP(pfInfo),  MPFROMSHORT(CMA_NEXT)));
            if (pNewData->ViewFlags & VIEW_MODIFYDATE)
               pfInfo->flData &= ~CFA_INVISIBLE;
            else
               pfInfo->flData |= CFA_INVISIBLE;

            // eighth col
            pfInfo = (PFIELDINFO) PVOIDFROMMR (WinSendMsg( _hCnrWnd,
            CM_QUERYDETAILFIELDINFO, MPFROMP(pfInfo),  MPFROMSHORT(CMA_NEXT)));
            if (pNewData->ViewFlags & VIEW_MODIFYTIME)
               pfInfo->flData &= ~CFA_INVISIBLE;
            else
               pfInfo->flData |= CFA_INVISIBLE;

            // ninth col
            pfInfo = (PFIELDINFO) PVOIDFROMMR (WinSendMsg( _hCnrWnd,
            CM_QUERYDETAILFIELDINFO, MPFROMP(pfInfo),  MPFROMSHORT(CMA_NEXT)));
            if (pNewData->ViewFlags & VIEW_LASTUSER)
               pfInfo->flData &= ~CFA_INVISIBLE;
            else
               pfInfo->flData |= CFA_INVISIBLE;

            // tenth col
            pfInfo = (PFIELDINFO) PVOIDFROMMR (WinSendMsg( _hCnrWnd,
            CM_QUERYDETAILFIELDINFO, MPFROMP(pfInfo),  MPFROMSHORT(CMA_NEXT)));
            if (pNewData->ViewFlags & VIEW_SIZE)
               pfInfo->flData &= ~CFA_INVISIBLE;
            else
               pfInfo->flData |= CFA_INVISIBLE;

            WinSendMsg (_hCnrWnd, CM_INVALIDATEDETAILFIELDINFO, 0, 0);
         }

      break;

   } /* endswitch */

   if ( (pOldData->FontSize  != pNewData->FontSize )  ||    // 138648  the text font changed
      strcmp(pOldData->FontName, pNewData->FontName ) ) {  //          needs to update
       bInvalidate = kODFalse;
   }
   if (!bInvalidate || !(memcmp(pOldData+sizeof(ULONG), pNewData+sizeof(ULONG),
                                                      sizeof(VIEWPAGEDATA)-sizeof(ULONG))))
   {
      char myStr[50];
      memset(myStr, 0, 50);
      ConvertViewPageDataToString(pNewData, myStr,somThis);
      WinSetPresParam(_hCnrWnd, PP_FONTNAMESIZE, strlen(myStr)+1, myStr);
   }

   memcpy (pOldData, pNewData, sizeof(VIEWPAGEDATA));
   if (bInvalidate)
      WinInvalidateRect(_hCnrWnd, NULL,FALSE);

   return TRUE;
}

//=============================================================================
// void  ODCnrViewCnrTerminateView();
//-----------------------------------------------------------------------------
// TerminateView will perform internal cleanup for this class.
//=============================================================================
SOM_Scope void  SOMLINK ODCnrViewCnrTerminateView( ODCnrView *somSelf,
                                                Environment *ev)
{
   ODCnrViewData *somThis = ODCnrViewGetData(somSelf);
   ODCnrViewMethodDebug("ODCnrView","ODCnrViewCnrTerminateView");
   somSelf->FreeRecordContents (ev);
}

//=============================================================================
SOM_Scope void  SOMLINK ODCnrViewNullhwnd(ODCnrView *somSelf, Environment *ev, HWND hwnd)
{
   ODCnrViewData *somThis = ODCnrViewGetData(somSelf);
   ODCnrViewMethodDebug("ODCnrView","ODCnrViewNyllhwnd");

   ODBoolean AllNull = TRUE;
   ODCnrViewsomUninit(somSelf);
   _Parent->TerminateView(      somGetGlobalEnvironment(),somSelf);

}

//=============================================================================
// void  ODCnrViewIterateAndLoadInfoTree()
//-----------------------------------------------------------------------------
// This method goes recursively through the entire tree structure and fills in the
// ODINFO structure that is passed in.
//=============================================================================
SOM_Scope void SOMLINK ODCnrViewIterateAndLoadInfoTree( ODCnrView *somSelf,
                        Environment *ev, ODPart * CurrentPart, PODINFO CurrentPartInfo)
{
        ODEmbeddedFramesIterator *CurrentFrameIter = kODNULL;
        ODFrame *ChildFrame = kODNULL;
        ODPart *ChildPart = kODNULL;
        PODINFO   NewODInfo=kODNULL, LastSibling = kODNULL;

        ODCnrViewData *somThis = ODCnrViewGetData(somSelf);
        ODCnrViewMethodDebug("ODCnrView","ODCnrViewIterateAndLoadInfoTree");

         CurrentPartInfo->cb = sizeof(ODINFO);
         somSelf->CnrRetrievePartAttributes(ev,CurrentPart,CurrentPartInfo);
         TRY
            CurrentFrameIter=CurrentPart->CreateEmbeddedFramesIterator(ev,kODNULL);
         CATCH_ALL
              // ...
         ENDTRY

         if (CurrentFrameIter) {
           TRY
              CurrentFrameIter->InitEmbeddedFramesIterator(ev,CurrentPart);
           CATCH_ALL
              // ...
           ENDTRY
           ChildFrame=CurrentFrameIter->First(ev);

           while (ChildFrame) {
                NewODInfo = PODINFO(malloc(sizeof(ODINFO)));
                memset((char *)NewODInfo, 0, sizeof(ODINFO));
                NewODInfo->partFrame = ChildFrame; // 141192  store the part frame.
                NewODInfo->BranchRoot = CurrentPartInfo;
                if (!(CurrentPartInfo->Leaf)) CurrentPartInfo->Leaf = NewODInfo;
                else {
                        LastSibling = CurrentPartInfo->Leaf;
                        while (LastSibling->Next) LastSibling = LastSibling->Next;
                        LastSibling->Next = NewODInfo;
                }
                ChildPart = ChildFrame->AcquirePart(ev);
                somSelf->IterateAndLoadInfoTree(ev,ChildPart,NewODInfo);

                ChildFrame = kODNULL;
                if (CurrentFrameIter->IsNotComplete(ev))
                        ChildFrame = CurrentFrameIter->Next(ev);
           }
           delete CurrentFrameIter;
        }
}

//=============================================================================
// void  ODCnrViewLoadPMViewWithAddCols()
// This is a special procedure which fills the records in the PM container that
// needs to show additional details for the embedded parts.
//=============================================================================
SOM_Scope void SOMLINK ODCnrViewLoadPMViewWithAddCols(ODCnrView *somSelf,
           Environment *ev, ODPart* rootPart, ODINFO *pCurrentInfo,
        ODULong ulNumberofColumns, HWND hCnrWnd)
{
   ODEmbeddedFramesIterator *CurrentFrameIter = kODNULL;
   ODCnrViewData *somThis = ODCnrViewGetData(somSelf);
   ODCnrViewMethodDebug("ODCnrView","ODCnrViewLoadPMViewWithAddCols");

   // Iterate through all the parts and collect the additional data that needs to be
   // displayed in the details view.

   CurrentFrameIter=rootPart->CreateEmbeddedFramesIterator(ev,kODNULL);
   if (CurrentFrameIter) {

      LONG AllocSize;
      void *AddColData = kODNULL;
      ODULong LenData = 0;
      ODStorageUnit   *su=kODNULL;
      ODPart *ChildPart;
      ODFrame *ChildFrame = kODNULL;
      PODINFO LeafInfo = kODNULL, pInf = kODNULL;
      PMINIRECORDCORE pRecordCore;
      void *AllData;
      RECORDINSERT    recsIn;

      pInf = pCurrentInfo;
      TRY
         CurrentFrameIter->InitEmbeddedFramesIterator(ev,rootPart);
      CATCH_ALL
         // ...
      ENDTRY
      ChildFrame=CurrentFrameIter->First(ev);

      while (ChildFrame) {

                // From Frame -> Get Part -> Get Storage unit -> Get data for additional columns.
                ChildPart = ChildFrame->AcquirePart(ev);
                su = ChildPart->GetStorageUnit(ev);
                somSelf->GetMoreDataFromPart(ev, _Parent, su,
                                        ulNumberofColumns, &AddColData, &LenData);

                // Allocate memory as per the total data to be displayed.
                AllocSize = sizeof(ODINFO)-sizeof(MINIRECORDCORE) + LenData;
                pRecordCore = (PMINIRECORDCORE)WinSendMsg(hCnrWnd, CM_ALLOCRECORD,
                         MPFROMLONG(AllocSize),MPFROMLONG(1));

                // Copy entire data in the memory allocated.
                LeafInfo = (PODINFO) pRecordCore;
                memcpy((char *) &LeafInfo->cb, (char *) &pInf->cb,
                     sizeof(ODINFO)-sizeof(MINIRECORDCORE));
                pRecordCore->hptrIcon = (pInf->RecordCore).hptrIcon;
                pRecordCore->pszIcon = (pInf->RecordCore).pszIcon;

                AllData = (void *) pRecordCore;
                memcpy((char *)((char *)AllData + sizeof(ODINFO)), (char *)AddColData, LenData);
                free (AddColData); AddColData = kODNULL;

                // Insert the record in the container.
                recsIn.cb = sizeof(RECORDINSERT);
                recsIn.pRecordParent = kODNULL;
                recsIn.pRecordOrder = (PRECORDCORE)CMA_END;
                recsIn.zOrder = (USHORT)CMA_TOP;
                recsIn.cRecordsInsert = (USHORT)1;
                recsIn.fInvalidateRecord = TRUE;
                WinSendMsg(hCnrWnd,  CM_INSERTRECORD,  (PMINIRECORDCORE)LeafInfo, &recsIn);

                ChildFrame = kODNULL;
                if (CurrentFrameIter->IsNotComplete(ev))
                               ChildFrame = CurrentFrameIter->Next(ev);
                if (pInf->Next) pInf = pInf->Next;
      }
      delete CurrentFrameIter;
   }
}

//-----------------------------------------------------------------------------
// This method gets the additional data from the storage unit of the part. It first
// gets the datatype, property name and value type of the storage unit data
// from the view extension object.
//-----------------------------------------------------------------------------
SOM_Scope void SOMLINK ODCnrViewGetMoreDataFromPart(ODCnrView *somSelf,
           Environment *ev, ODViewExtension *vx, ODStorageUnit *su,
                ODULong numCols, void ** ppData,  ODULong *len)
{
   ODCnrViewData *somThis = ODCnrViewGetData(somSelf);
   ODCnrViewMethodDebug("ODCnrView","ODCnrViewGetMoreDataFromPart");

   ODULong i;
   char *sColDataType, *sPartSUPropName, *sPartSUValName;

   *len = 0;
   for (i = 0; i < numCols; i++) {
        vx->RetrievePartAttributes(ev, &sColDataType, &sPartSUPropName,
                &sPartSUValName, &i);
        su->Focus(ev, sPartSUPropName, kODPosUndefined, sPartSUValName,
                   0, kODPosUndefined);

        // Get data based on the data type.
        if (!strcmp(sColDataType, kODISOStr)) {
           ODULong sz = su->GetSize(ev);
           char *val;
           val = (char *) malloc(sz);
           StorageUnitGetValue(su, ev, sz, (ODPtr)val);
           val[sz-1] = '\0';
           * ppData = realloc(*ppData, *len + sizeof(char *));
           memcpy((char *)((char *)(*ppData) + *len), (char *)&val, sizeof(char *));
           *len += sizeof(char *);
        }
        else if (!strcmp(sColDataType, kODULong)) {
           ODULong val;
           StorageUnitGetValue(su, ev, sizeof(ODULong), (ODPtr)&val);
           * ppData = realloc(*ppData, *len + sizeof(ODULong));
           memcpy((char *)((char *)(*ppData) + *len), (char *)&val, sizeof(ODULong));
           *len += sizeof(ODULong);
        }
        else if (!strcmp(sColDataType, kODTime_T)) {
           time_t val;
           CTIME ctime;
           struct tm c_tm;

           StorageUnitGetValue(su, ev, sizeof(time_t), (ODPtr)&val);
           c_tm = *localtime(&val);
           ctime.hours = (UCHAR) c_tm.tm_hour;
           ctime.minutes = (UCHAR) c_tm.tm_min;
           ctime.seconds = (UCHAR) c_tm.tm_sec;

           * ppData = realloc(*ppData, *len + sizeof(CTIME));
           memcpy((char *)((char *)(*ppData) + *len), (char *)&ctime, sizeof(CTIME));
           *len += sizeof(CTIME);
        }
        else if (!strcmp(sColDataType, kODDate)) {
           time_t val;
           CDATE cdate;
           struct tm c_tm;

           StorageUnitGetValue(su, ev, sizeof(time_t), (ODPtr)&val);
           c_tm = *localtime(&val);
           cdate.day = (UCHAR) c_tm.tm_mday;
           cdate.month = (UCHAR) c_tm.tm_mon;
           cdate.year = (USHORT) c_tm.tm_year;

           * ppData = realloc(*ppData, *len + sizeof(CDATE));
           memcpy((char *)((char *)(*ppData) + *len), (char *)&cdate, sizeof(CDATE));
           *len += sizeof(CDATE);
        }
        else if (!strcmp(sColDataType, kODIconFamily)) {

           HPOINTER hIcon = kODNULL;
           hIcon = GetHPOINTERFromSU (ev, su, sPartSUPropName, sPartSUValName);

           * ppData = realloc(*ppData, *len + sizeof(HPOINTER));
           memcpy((char *)((char *)(*ppData) + *len), (char *)&hIcon, sizeof(HPOINTER));
           *len += sizeof(HPOINTER);
        }
   }
}

//-----------------------------------------------------------------------------
// The following method frees all the memory used by strings and icons for
// each of the records.
// We first get the view type. If it is tree or icon view, we free the icon and
// the text of the icon. Else if it is details view, then we iterate through
// each column and free icons and strings.
//-----------------------------------------------------------------------------
SOM_Scope void SOMLINK ODCnrViewFreeRecordContents(ODCnrView *somSelf,
           Environment *ev)
{
   ODCnrViewData *somThis = ODCnrViewGetData(somSelf);
   ODCnrViewMethodDebug("ODCnrView","ODCnrViewRemoveAndFreeRecords");

   CNRINFO cInfo;
   USHORT retNum;
   ODULong vType;

   memset(&cInfo, 0, sizeof(CNRINFO));
   // Get view type.
   WinSendMsg(_hCnrWnd, CM_QUERYCNRINFO, MPFROMP(&cInfo),
                                         MPFROMSHORT(sizeof(CNRINFO)) );
   if ((cInfo.flWindowAttr & CV_TREE) == CV_TREE) vType = OD_TREEVIEW;
   else if ((cInfo.flWindowAttr & CV_DETAIL) == CV_DETAIL) vType = OD_DETAILSVIEW;
   else vType = OD_ICONVIEW;

   switch (vType) {

      // This is the simplest as there are no child records.
      case OD_ICONVIEW:
      {
         MINIRECORDCORE *pRecord =  (MINIRECORDCORE *) PVOIDFROMMR(
                                                    WinSendMsg(_hCnrWnd,CM_QUERYRECORD,
                                                    0, MPFROM2SHORT(CMA_FIRST,CMA_ITEMORDER)));
         while (pRecord) {
            if (pRecord->pszIcon) delete[] (pRecord->pszIcon);
            if (pRecord->hptrIcon) WinDestroyPointer (pRecord->hptrIcon);

            pRecord =  (MINIRECORDCORE *) PVOIDFROMMR(
                            WinSendMsg(_hCnrWnd, CM_QUERYRECORD,
                            MPFROMP(pRecord), MPFROM2SHORT(CMA_NEXT,CMA_ITEMORDER)));
         }
      }
      break;

      // In tree view, we have to iterate through the child records too.
      case OD_TREEVIEW:
      {
         MINIRECORDCORE *pRecord =  (MINIRECORDCORE *) PVOIDFROMMR(
                                                    WinSendMsg(_hCnrWnd,CM_QUERYRECORD,
                                                    0, MPFROM2SHORT(CMA_FIRST,CMA_ITEMORDER)));
         if (pRecord)
            FreeTreeRecordContents (_hCnrWnd, pRecord);
      }
      break;

      // In details view we have to free all the strings. Currently we are not freeing
      // memory in additional columns.
      case OD_DETAILSVIEW:
      {
         ODINFO *pRecord =  (ODINFO *) PVOIDFROMMR(
                                                    WinSendMsg(_hCnrWnd,CM_QUERYRECORD,
                                                    0, MPFROM2SHORT(CMA_FIRST,CMA_ITEMORDER)));
         while (pRecord) {
            if ((pRecord->RecordCore).pszIcon) free ((pRecord->RecordCore).pszIcon);
            if ((pRecord->RecordCore).hptrIcon)
                                         WinDestroyPointer ((pRecord->RecordCore).hptrIcon);

            if (pRecord->partKind) delete[] (pRecord->partKind);
            if (pRecord->partCategory) delete[] (pRecord->partCategory);
            if (pRecord->partEditor) delete[] (pRecord->partEditor);
            if (pRecord->partCreateDate) delete[] (pRecord->partCreateDate);
            if (pRecord->partCreateTime) delete[] (pRecord->partCreateTime);
            if (pRecord->partLastModifyDate) delete[] (pRecord->partLastModifyDate);
            if (pRecord->partLastModifyTime) delete[] (pRecord->partLastModifyTime);
            if (pRecord->partLastModifyUser) delete[] (pRecord->partLastModifyUser);

            pRecord =  (ODINFO *) PVOIDFROMMR(
                            WinSendMsg(_hCnrWnd, CM_QUERYRECORD,
                            MPFROMP(pRecord), MPFROM2SHORT(CMA_NEXT,CMA_ITEMORDER)));
         }
      }
      break;
   }

}

//=============================================================================
SOM_Scope void  SOMLINK ODCnrViewsomInit(ODCnrView *somSelf)
{
   ODCnrViewData *somThis = ODCnrViewGetData(somSelf);
   ODCnrViewMethodDebug("ODCnrView","ODCnrViewsomInit");
   _ViewProps = 0L;
   ODCnrView_parent_ODObject_somInit(somSelf);
}

//=============================================================================
SOM_Scope void  SOMLINK ODCnrViewsomUninit(ODCnrView *somSelf)
{
   ODCnrViewData *somThis = ODCnrViewGetData(somSelf);
   ODCnrViewMethodDebug("ODCnrView","ODCnrViewsomUninit");
   delete _ViewProps;     // 145698
   ODCnrView_parent_ODObject_somUninit(somSelf);
}

// routine to get string from resource file string table.

char * GetStringFromTable (ODCnrViewData *somThis,ULONG menuid)
{
  char str[CV_MAXSTRLEN];      // 130251
  WinLoadString(WinQueryAnchorBlock(HWND_DESKTOP), _hmod,
            menuid, (LONG) CV_MAXSTRLEN, str);      // 130251
  char * tmp =  new char[strlen (str)+1];     /* Preview text               */
  strcpy(tmp,str);     /* Preview text               */
  return tmp;
} // end of routine GetStringFromTable
